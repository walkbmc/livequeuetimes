{"version":3,"sources":["../lib/geoLocation.js"],"names":["s_longitude","Symbol","s_latitude","GeoLocation","longitude","latitude","parseFloat","undefined","Error","Math","max","min","Latitude","Longitude","LatitudeRaw","LongitudeRaw","formatNumberToGeoLocation","locationA","locationB","random","number","locationMinutes","floor","locationSeconds","toFixed","module","exports"],"mappings":"AAAA;;;;;;AAEA,IAAIA,cAAcC,QAAlB;AACA,IAAIC,aAAaD,QAAjB;;AAEA;;;;;IAIME,W;AACF;;;;;AAKA,+BAGG;AAAA,kCAFCC,SAED;AAAA,YAFCA,SAED,kCAFa,CAEb;AAAA,iCADCC,QACD;AAAA,YADCA,QACD,iCADY,CACZ;;AAAA;;AACC,aAAKL,WAAL,IAAoBM,WAAWF,SAAX,CAApB;AACA,aAAKF,UAAL,IAAmBI,WAAWD,QAAX,CAAnB;;AAEA;AACA,YAAI,KAAKL,WAAL,MAAsBO,SAAtB,IAAmC,OAAO,KAAKP,WAAL,CAAP,IAA6B,QAApE,EAA8E;AAC1E,kBAAM,IAAIQ,KAAJ,CAAU,4CAA4C,KAAKR,WAAL,CAAtD,CAAN;AACH;AACD,YAAI,KAAKE,UAAL,MAAqBK,SAArB,IAAkC,OAAO,KAAKL,UAAL,CAAP,IAA4B,QAAlE,EAA4E;AACxE,kBAAM,IAAIM,KAAJ,CAAU,2CAA2C,KAAKN,UAAL,CAArD,CAAN;AACH;;AAED;AACA;AACA,aAAKF,WAAL,IAAoB,KAAKA,WAAL,IAAoB,GAAxC;AACA,YAAI,KAAKA,WAAL,IAAoB,GAAxB,EAA6B,KAAKA,WAAL,KAAqB,GAArB;;AAE7B;AACA,aAAKE,UAAL,IAAmBO,KAAKC,GAAL,CAAS,CAAC,EAAV,EAAcD,KAAKE,GAAL,CAAS,KAAKT,UAAL,CAAT,EAA2B,EAA3B,CAAd,CAAnB;AACH;;AAED;;;;;;;;;;;AA0CA;;;;mCAIW;AACP,yBAAW,KAAKU,QAAhB,UAA6B,KAAKC,SAAlC;AACH;;AAED;;;;;;;uCAIe;AACX,mBAAO,gCAAgC,KAAKC,WAArC,GAAmD,GAAnD,GAAyD,KAAKC,YAArE;AACH;;AAED;;;;;;;4BArDgB;AACZ,gBAAI,KAAKf,WAAL,IAAoB,CAAxB,EAA2B;AACvB,uBAAOgB,0BAA0B,CAAC,KAAKhB,WAAL,CAA3B,IAAgD,GAAvD;AACH,aAFD,MAEO;AACH,uBAAOgB,0BAA0B,KAAKhB,WAAL,CAA1B,IAA+C,GAAtD;AACH;AACJ;;AAED;;;;;;;4BAImB;AACf,mBAAO,KAAKA,WAAL,CAAP;AACH;;AAED;;;;;;;;4BAKe;AACX,gBAAI,KAAKE,UAAL,IAAmB,CAAvB,EAA0B;AACtB,uBAAOc,0BAA0B,CAAC,KAAKd,UAAL,CAA3B,IAA+C,GAAtD;AACH,aAFD,MAEO;AACH,uBAAOc,0BAA0B,KAAKd,UAAL,CAA1B,IAA8C,GAArD;AACH;AACJ;;AAED;;;;;;;4BAIkB;AACd,mBAAO,KAAKA,UAAL,CAAP;AACH;;;sCAsBoBe,S,EAAWC,S,EAAW;AACvC,mBAAO,IAAIf,WAAJ,CAAgB;AACnBC,2BAAWa,UAAUF,YAAV,GAA0BN,KAAKU,MAAL,MAAiBD,UAAUH,YAAV,GAAyBE,UAAUF,YAApD,CADlB;AAEnBV,0BAAUY,UAAUH,WAAV,GAAyBL,KAAKU,MAAL,MAAiBD,UAAUJ,WAAV,GAAwBG,UAAUH,WAAnD;AAFhB,aAAhB,CAAP;AAIH;;;;;;AAGL;;;;;;;AAKA,SAASE,yBAAT,CAAmCI,MAAnC,EAA2C;AACvC;AACA,QAAIC,kBAAkBZ,KAAKa,KAAL,CAAYF,SAAS,CAAV,GAAe,EAA1B,CAAtB;AACA,QAAIG,kBAAkB,CAAGH,SAAS,EAAV,GAAgB,CAAjB,GAAsB,EAAvB,EAA2BI,OAA3B,CAAmC,CAAnC,CAAtB;;AAEA;AACA,WAAUf,KAAKa,KAAL,CAAWF,MAAX,CAAV,YAAqCC,eAArC,cAA6DE,eAA7D;AACH;;AAEDE,OAAOC,OAAP,GAAiBvB,WAAjB","file":"geoLocation.js","sourcesContent":["\"use strict\";\r\n\r\nvar s_longitude = Symbol();\r\nvar s_latitude = Symbol();\r\n\r\n/**\r\n * GeoLocation class to store theme park locations and supply helper functions\r\n * @class\r\n */\r\nclass GeoLocation {\r\n    /**\r\n     * @param {Object} location\r\n     * @param {Number} location.longitude - New location's longitude\r\n     * @param {Number} location.latitude - New location's latitude\r\n     * */\r\n    constructor({\r\n        longitude = 0,\r\n        latitude = 0\r\n    }) {\r\n        this[s_longitude] = parseFloat(longitude);\r\n        this[s_latitude] = parseFloat(latitude);\r\n\r\n        // validate longitude and latitude\r\n        if (this[s_longitude] === undefined || typeof(this[s_longitude]) != \"number\") {\r\n            throw new Error(\"Invalid/Undefined value for longitude: \" + this[s_longitude]);\r\n        }\r\n        if (this[s_latitude] === undefined || typeof(this[s_latitude]) != \"number\") {\r\n            throw new Error(\"Invalid/Undefined value for latitude: \" + this[s_latitude]);\r\n        }\r\n\r\n        // wrap longitude and latitude around so they are in a standard format for us to use\r\n        //  longitude should be between -180,180\r\n        this[s_longitude] = this[s_longitude] % 360;\r\n        if (this[s_longitude] > 180) this[s_longitude] -= 360;\r\n\r\n        //  latitude should be clamped between -90,90 (if we go too far north, we don't want to wrap around to the south)\r\n        this[s_latitude] = Math.max(-90, Math.min(this[s_latitude], 90));\r\n    }\r\n\r\n    /**\r\n     * Return the formatted longitude for this location\r\n     * Formatted as XX°YY′ZZ″\r\n     * @type {String}\r\n     * */\r\n    get Longitude() {\r\n        if (this[s_longitude] < 0) {\r\n            return formatNumberToGeoLocation(-this[s_longitude]) + \"W\";\r\n        } else {\r\n            return formatNumberToGeoLocation(this[s_longitude]) + \"E\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the raw numeric value of this position's longitude\r\n     * @type {Number}\r\n     * */\r\n    get LongitudeRaw() {\r\n        return this[s_longitude];\r\n    }\r\n\r\n    /**\r\n     * Return the formatted latitude for this location\r\n     * Formatted as XX°YY′\r\n     * @type {String}\r\n     * */\r\n    get Latitude() {\r\n        if (this[s_latitude] < 0) {\r\n            return formatNumberToGeoLocation(-this[s_latitude]) + \"S\";\r\n        } else {\r\n            return formatNumberToGeoLocation(this[s_latitude]) + \"N\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the raw numeric value of this position's latitude\r\n     * @type {Number}\r\n     * */\r\n    get LatitudeRaw() {\r\n        return this[s_latitude];\r\n    }\r\n\r\n    /**\r\n     * Return this GeoLocation safe for printing\r\n     * @returns {String} Location String formatted as: ([latitude], [longitude])\r\n     * */\r\n    toString() {\r\n        return `(${this.Latitude}, ${this.Longitude})`;\r\n    }\r\n\r\n    /**\r\n     * Return a URL to this park on Google Maps\r\n     * @returns {String} URL to this park on Google Maps\r\n     * */\r\n    toGoogleMaps() {\r\n        return \"http://maps.google.com/?ll=\" + this.LatitudeRaw + \",\" + this.LongitudeRaw;\r\n    }\r\n\r\n    /**\r\n     * Return a random point between two GeoLocation objects\r\n     * @returns {GeoLocation} New GeoLocation object randomly set between locationA and locationB\r\n     */\r\n    static RandomBetween(locationA, locationB) {\r\n        return new GeoLocation({\r\n            longitude: locationA.LongitudeRaw + (Math.random() * (locationB.LongitudeRaw - locationA.LongitudeRaw)),\r\n            latitude: locationA.LatitudeRaw + (Math.random() * (locationB.LatitudeRaw - locationA.LatitudeRaw)),\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Format a decimal number to [Int]\\u00B0 [Remainder]\\u2032\r\n * @private\r\n * @returns {String} Formatted string representing this number in XX° YY′ ZZ″\r\n * */\r\nfunction formatNumberToGeoLocation(number) {\r\n    // work out minutes and seconds for this input\r\n    var locationMinutes = Math.floor((number % 1) * 60);\r\n    var locationSeconds = (((number * 60) % 1) * 60).toFixed(2);\r\n\r\n    // return formatted string\r\n    return `${Math.floor(number)}\\u00B0${locationMinutes}\\u2032${locationSeconds}\\u2033`;\r\n}\r\n\r\nmodule.exports = GeoLocation;"]}