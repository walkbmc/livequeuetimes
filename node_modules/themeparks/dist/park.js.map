{"version":3,"sources":["../lib/park.js"],"names":["GeoLocation","require","DebugLog","Promise","moment","random_useragent","Settings","HTTPLib","CacheLib","Ride","Schedule","DefaultTimeFormat","SocksProxyAgent","HttpsProxyAgent","s_parkName","Symbol","s_parkTimezone","s_parkGeolocation","s_parkTimeFormat","s_parkDateFormat","s_useragent","s_cacheTimeWaitTimes","s_cacheTimeOpeningTimes","s_rideIDToIDXMap","s_scheduleData","s_scheduleDaysToReturn","s_cacheObject","Park","options","constructor","TypeError","name","DefaultParkName","timezone","DefaultParkTimezone","timeFormat","DefaultParkTimeFormat","dateFormat","DefaultDateFormat","cacheWaitTimesLength","cacheOpeningTimesLength","scheduleDaysToReturn","DefaultScheduleDays","tz","zone","Error","latitude","longitude","UserAgent","useragent","ua","osName","Rides","prefix","callback","arguments","length","GetWaitTimesPromise","then","data","bind","error","ride","Log","id","undefined","className","String","substr","newRide","ride_id","ride_name","push","resolve","reject","SupportsWaitTimes","Name","Cache","Get","ridedata","i","GetRideObject","fromJSON","result","toJSON","err","FetchWaitTimes","Set","ttl","DefaultCacheWaitTimesLength","GetOpeningTimesPromise","SupportsOpeningTimes","openingTimesData","GetDateRange","startDate","endDate","add","ScheduleDays","FetchOpeningTimes","endFillDate","Timezone","m","isBefore","dateData","GetDate","date","SetDate","type","IsDirty","DefaultCacheOpeningTimesLength","format","TimeNow","headers","open_timeout","DefaultOpenTimeout","read_timeout","DefaultReadTimeout","ProxyURL","startsWith","agent","getRandom","module","exports"],"mappings":"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","file":"park.js","sourcesContent":["\"use strict\";\r\n\r\n// our simple geolocation object library\r\nvar GeoLocation = require(\"./geoLocation.js\");\r\n// a basic debug log wrapper\r\nvar DebugLog = require(\"./debugPrint.js\");\r\n\r\n// include our Promise library\r\nvar Promise = require(\"./promise\");\r\n\r\n// MomentJS time library\r\nvar moment = require(\"moment-timezone\");\r\n// random useragent generator\r\nvar random_useragent = require(\"random-useragent\");\r\n\r\n// load user settings\r\nvar Settings = require(\"./settings\");\r\n\r\n// wrap the HTTP lib for each park so we automatically pass the User-Agent header nicely along\r\nvar HTTPLib = require(\"./http\");\r\n\r\n// our caching library, each park will get it's own cache object\r\nvar CacheLib = require(\"./cache\");\r\n\r\n// our Ride object\r\nvar Ride = require(\"./ride\");\r\n// our Schedule class\r\nvar Schedule = require(\"./schedule\");\r\n\r\n// default time format for returning times\r\nvar DefaultTimeFormat = \"YYYY-MM-DDTHH:mm:ssZ\";\r\n\r\nvar SocksProxyAgent = require(\"socks-proxy-agent\");\r\nvar HttpsProxyAgent = require(\"https-proxy-agent\");\r\n\r\n// park symbols\r\nvar s_parkName = Symbol();\r\nvar s_parkTimezone = Symbol();\r\nvar s_parkGeolocation = Symbol();\r\nvar s_parkTimeFormat = Symbol();\r\nvar s_parkDateFormat = Symbol();\r\nvar s_useragent = Symbol();\r\nvar s_cacheTimeWaitTimes = Symbol();\r\nvar s_cacheTimeOpeningTimes = Symbol();\r\n// track which Ride ID is at which index in our Rides array\r\nvar s_rideIDToIDXMap = Symbol();\r\n// key for our schedule data\r\nvar s_scheduleData = Symbol();\r\n// how many days to return for opening time schedules\r\nvar s_scheduleDaysToReturn = Symbol();\r\n\r\n// our cache object\r\nvar s_cacheObject = Symbol();\r\n\r\n/**\r\n * Park class handles all the base logic for all implemented themeparks.\r\n * All parks should inherit from this base class.\r\n * Any common functionality is implemented here to save endless re-implementations for each park.\r\n * @class\r\n */\r\nclass Park {\r\n    /**\r\n     * Create a new Park object\r\n     * @param {Object} options\r\n     * @param {String} options.name The name of this park\r\n     * @param {String} options.timezone Park's timezone\r\n     * @param {String} [options.timeFormat] Format to display park times in\r\n     * @param {String} [options.dateFormat] Format to display park dates in\r\n     * @param {Number} [options.cacheWaitTimesLength=300] How long (in seconds) to cache wait times before fetching fresh time\r\n     * @param {Number} options.latitude Park's latitude\r\n     * @param {Number} options.longitude Park's longitude\r\n     * @param {String} [options.useragent] Useragent to use when making HTTP requests\r\n     * @param {Number} [options.scheduleDaysToReturn] Days of opening times to return with GetOpeningTimes()\r\n     */\r\n    constructor(options = {}) {\r\n        // can only construct actual parks, not the park object itself\r\n        //  see http://ilikekillnerds.com/2015/06/abstract-classes-in-javascript/\r\n        if (this.constructor === Park) {\r\n            throw new TypeError(\"Cannot create Park object directly, only park implementations of Park\");\r\n        }\r\n\r\n        // take base variables from the constructor\r\n        //  these variables should be present for all parks\r\n        // what's up with these OR things?\r\n        //  by default, use any manually passed in options\r\n        //  finally, fallback on the default settings\r\n        this[s_parkName] = options.name || Settings.DefaultParkName;\r\n        this[s_parkTimezone] = options.timezone || Settings.DefaultParkTimezone;\r\n        this[s_parkTimeFormat] = options.timeFormat || Settings.DefaultParkTimeFormat;\r\n        this[s_parkDateFormat] = options.dateFormat || Settings.DefaultDateFormat;\r\n\r\n        // cache settings\r\n        //  how long wait times are cached before fetching new data\r\n        this[s_cacheTimeWaitTimes] = options.cacheWaitTimesLength;\r\n        this[s_cacheTimeOpeningTimes] = options.cacheOpeningTimesLength;\r\n\r\n        // how many schedule days to return?\r\n        this[s_scheduleDaysToReturn] = options.scheduleDaysToReturn || Settings.DefaultScheduleDays;\r\n\r\n        // validate park's timezone with momentjs\r\n        if (!moment.tz.zone(this[s_parkTimezone])) {\r\n            throw new Error(`Invalid timezone ${this[s_parkTimezone]} passed to park constructor.`);\r\n        }\r\n\r\n        // create a geolocation object if we've been passed a longitude and latitude\r\n        if (!this[s_parkGeolocation] && typeof(options.latitude) == \"number\" && typeof(options.longitude) == \"number\") {\r\n            this[s_parkGeolocation] = new GeoLocation({\r\n                longitude: options.longitude,\r\n                latitude: options.latitude\r\n            });\r\n        }\r\n\r\n        // validate our geolocation object has been created\r\n        if (!this[s_parkGeolocation]) {\r\n            throw new Error(`No park GeoLocation object created for ${this.name}. Please supply longitude and latitude for this park.`);\r\n        }\r\n\r\n        // set useragent, or if no useragent has been set, create a random Android one by default\r\n        this.UserAgent = options.useragent || function(ua) {\r\n            return (ua.osName == \"Android\");\r\n        };\r\n\r\n        // initialise the Rides array\r\n        this.Rides = [];\r\n        // also initialise our ride ID -> idx map\r\n        this[s_rideIDToIDXMap] = {};\r\n\r\n        // make a new schedule object for storing park opening hours in\r\n        this[s_scheduleData] = new Schedule({\r\n            timeFormat: this[s_parkTimeFormat],\r\n            dateFormat: this[s_parkDateFormat],\r\n        });\r\n\r\n        // create cache object for this park\r\n        this[s_cacheObject] = new CacheLib({\r\n            prefix: this.constructor.name\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get waiting times for rides from this park\r\n     * If the last argument is a function, this will act as a callback.\r\n     *  Callback will call with callback(error, data)\r\n     *  Data will be null if error is present\r\n     * If the last argument is not a function, this will return a Promise.\r\n     */\r\n    GetWaitTimes() {\r\n        var callback = arguments[arguments.length - 1];\r\n        // if our last argument is a function, use it as a callback\r\n        if (typeof callback == \"function\") {\r\n            // translate the promise result into a \"classic\" callback response\r\n            this.GetWaitTimesPromise().then(function(data) {\r\n                callback(null, data);\r\n            }.bind(this), function(error) {\r\n                callback(error);\r\n            }.bind(this));\r\n            // otherwise, return a Promise object\r\n        } else {\r\n            return this.GetWaitTimesPromise();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fetch the ride data for the requested ID. If it doesn't exist, add a new ride to our park's ride set\r\n     * @param {Object} ride - Ride data to apply\r\n     * @param {String} ride.id - Ride's ID\r\n     * @param {String} ride.name - Ride's name\r\n     * @returns {Ride} ride - Newly created (or the existing) Ride object\r\n     */\r\n    GetRideObject(ride = {}) {\r\n        if (!ride) {\r\n            this.Log(\"No Ride Data supplied to GetRideObject\");\r\n            return null;\r\n        }\r\n        if (ride.id === undefined) {\r\n            this.Log(\"No Ride ID supplied to GetRideObject\", ride);\r\n            return null;\r\n        }\r\n        if (ride.name === undefined) {\r\n            this.Log(\"No Ride name supplied to GetRideObject\", ride);\r\n            return null;\r\n        }\r\n\r\n        // prepend the park's class name to the ID to attempt to ensure uniqueness\r\n        var className = this.constructor.name;\r\n        if (String(ride.id).substr(0, className.length) !== className) {\r\n            ride.id = `${className}_${ride.id}`;\r\n        }\r\n\r\n        // check if we don't already have this ride in our data set\r\n        if (this[s_rideIDToIDXMap][ride.id] === undefined) {\r\n\r\n            // new ride! add to our set\r\n            var newRide = new Ride({\r\n                ride_id: ride.id,\r\n                ride_name: ride.name,\r\n            });\r\n\r\n            // add our new ride to our ride list and make an ID mapping\r\n            this.Rides.push(newRide);\r\n            this[s_rideIDToIDXMap][ride.id] = this.Rides.length - 1;\r\n        }\r\n\r\n        // else, don't worry about it, fail quietly\r\n        // return the already existing ride\r\n        return this.Rides[this[s_rideIDToIDXMap][ride.id]];\r\n    }\r\n\r\n    /**\r\n     * Fetch the ride data for the requested ID. If it doesn't exist, returns null\r\n     * @param {Object} ride - Ride data to search for\r\n     * @param {String} ride.id - Ride's ID\r\n     * @returns {Ride} ride - Existing Ride object (or null if it doesn't exist)\r\n     */\r\n    FindRideObject(ride = {}) {\r\n        if (!ride) {\r\n            this.Log(\"No Ride Data supplied to FindRideObject\");\r\n            return null;\r\n        }\r\n        if (ride.id === undefined) {\r\n            this.Log(\"No Ride ID supplied to FindRideObject\", ride);\r\n            return null;\r\n        }\r\n\r\n        // prepend the park's class name to the ID to attempt to ensure uniqueness\r\n        var className = this.constructor.name;\r\n        if (String(ride.id).substr(0, className.length) !== className) {\r\n            ride.id = `${className}_${ride.id}`;\r\n        }\r\n\r\n        // check if we have this ride yet\r\n        if (this[s_rideIDToIDXMap][ride.id] === undefined) {\r\n            return null;\r\n        }\r\n\r\n        // return the already existing ride\r\n        return this.Rides[this[s_rideIDToIDXMap][ride.id]];\r\n    }\r\n\r\n    /** \r\n     * Get waiting times for rides from this park\r\n     * @returns {Promise}\r\n     */\r\n    GetWaitTimesPromise() {\r\n        return new Promise(function(resolve, reject) {\r\n            // do we actually support wait times?\r\n            if (!this.SupportsWaitTimes) {\r\n                return reject(`${this.Name} doesn't support fetching wait times`);\r\n            }\r\n\r\n            // check our cache first\r\n            this.Cache.Get(\"waittimes\").then(function(ridedata) {\r\n                // we have ridedata from the cache! apply over our current ride data\r\n                for (var i = 0, ride; ride = ridedata[i++];) {\r\n                    // restore ride state from cache\r\n                    this.GetRideObject(ride).fromJSON(ride);\r\n                }\r\n\r\n                // make an array of all the ride states\r\n                var result = [];\r\n                for (i = 0; ride = this.Rides[i++];) {\r\n                    result.push(ride.toJSON());\r\n                }\r\n                return resolve(result);\r\n            }.bind(this), function(err) {\r\n                if (err) {\r\n                    this.Log(`Error fetching cached wait times: ${err}`);\r\n                }\r\n\r\n                // cache missing key or the cached data has expired. Fetch new data!\r\n                this.FetchWaitTimes().then(function() {\r\n                    // success! the this.Rides array should now be populated\r\n                    //  cache the Rides array and return result\r\n                    var result = [];\r\n                    for (var i = 0, ride; ride = this.Rides[i++];) {\r\n                        result.push(ride.toJSON());\r\n                    }\r\n\r\n                    this.Cache.Set(\"waittimes\", result, {\r\n                        // either use the options.cacheWaitTimesLength or the default cache time length\r\n                        ttl: this[s_cacheTimeWaitTimes] || Settings.DefaultCacheWaitTimesLength\r\n                    }).then(function() {\r\n                        resolve(result);\r\n                    }.bind(this), reject);\r\n                }.bind(this), function(err) {\r\n                    // failed to fetch wait times, reject Promise\r\n                    return reject(`Error fetching park wait times: ${err}`);\r\n                }.bind(this));\r\n            }.bind(this));\r\n        }.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Get opening times for this park\r\n     * If the last argument is a function, this will act as a callback.\r\n     *  Callback will call with callback(error, data)\r\n     *  Data will be null if error is present\r\n     * If the last argument is not a function, this will return a Promise.\r\n     */\r\n    GetOpeningTimes() {\r\n        var callback = arguments[arguments.length - 1];\r\n        // if our last argument is a function, use it as a callback\r\n        if (typeof callback == \"function\") {\r\n            // translate the promise result into a \"classic\" callback response\r\n            this.GetOpeningTimesPromise().then(function(data) {\r\n                callback(null, data);\r\n            }.bind(this), function(error) {\r\n                callback(error);\r\n            }.bind(this));\r\n            // otherwise, return a Promise object\r\n        } else {\r\n            return this.GetOpeningTimesPromise();\r\n        }\r\n    }\r\n\r\n    /** \r\n     * Get opening times for this park\r\n     * @returns {Promise}\r\n     */\r\n    GetOpeningTimesPromise() {\r\n        return new Promise(function(resolve, reject) {\r\n            // do we actually support opening times?\r\n            if (!this.SupportsOpeningTimes) {\r\n                return reject(`${this.Name} doesn't support fetching opening times`);\r\n            }\r\n\r\n            // check our cache first\r\n            this.Cache.Get(\"openingtimes\").then(function(openingTimesData) {\r\n                // restore schedule from cached data\r\n                this[s_scheduleData].fromJSON(openingTimesData);\r\n\r\n                // fetch date range to return\r\n                return resolve(this[s_scheduleData].GetDateRange({\r\n                    startDate: moment(),\r\n                    endDate: moment().add(this.ScheduleDays, \"days\"),\r\n                }));\r\n            }.bind(this), function() {\r\n                // cache missing key or the cached data has expired. Fetch new data!\r\n                this.FetchOpeningTimes().then(function() {\r\n                    // fill in any missing days in the next period as closed\r\n                    var endFillDate = moment().tz(this.Timezone).add(this.ScheduleDays + 90, \"days\");\r\n                    for (var m = moment().tz(this.Timezone); m.isBefore(endFillDate); m.add(1, \"day\")) {\r\n                        var dateData = this.Schedule.GetDate({\r\n                            date: m\r\n                        });\r\n                        if (!dateData) {\r\n                            this.Schedule.SetDate({\r\n                                date: m,\r\n                                type: \"Closed\"\r\n                            });\r\n                        }\r\n                    }\r\n\r\n                    // resolve with our new schedule data\r\n                    resolve(this[s_scheduleData].GetDateRange({\r\n                        startDate: moment(),\r\n                        endDate: moment().add(this.ScheduleDays, \"days\"),\r\n                    }));\r\n\r\n                    // if the data is now dirty, cache it\r\n                    if (this[s_scheduleData].IsDirty) {\r\n                        // save schedule data in cache\r\n                        this.Cache.Set(\"openingtimes\", this[s_scheduleData].toJSON(), {\r\n                            // either use the options.s_cacheTimeOpeningTimes or the default cache time length\r\n                            ttl: this[s_cacheTimeOpeningTimes] || Settings.DefaultCacheOpeningTimesLength\r\n                        }, function(err) {\r\n                            if (err) {\r\n                                // if we error, console out, but don't fail (still return data)\r\n                                this.Log(`Error setting cache data for ${this.Name}`);\r\n                            }\r\n\r\n                            // mark data as no longer dirty (no longer needs caching)\r\n                            this[s_scheduleData].IsDirty = false;\r\n                        }.bind(this));\r\n                    }\r\n                }.bind(this), function(err) {\r\n                    // failed to fetch opening times, reject Promise\r\n                    return reject(`Error fetching park opening times: ${err}`);\r\n                }.bind(this));\r\n            }.bind(this));\r\n        }.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Get this park's geolocation object\r\n     * @type {GeoLocation}\r\n     * */\r\n    get Location() {\r\n        return this[s_parkGeolocation];\r\n    }\r\n\r\n    /**\r\n     * Get this park's name in a human-readable form\r\n     * @type {String}\r\n     * */\r\n    get Name() {\r\n        return this[s_parkName];\r\n    }\r\n\r\n    /**\r\n     * Get this park's useragent string for making network requests\r\n     * This is usually randomly generated on object construction\r\n     * @type {String}\r\n     */\r\n    get UserAgent() {\r\n        return this[s_useragent];\r\n    }\r\n\r\n    /**\r\n     * Set this park's useragent\r\n     * Can set user agent to a defined string or use a generator function (see random-useragent library)\r\n     * @type {string|function}\r\n     */\r\n    set UserAgent(useragent = null) {\r\n        if (!useragent) throw new Error(\"No configuration passed to UserAgent setter\");\r\n\r\n        if (typeof(useragent) == \"function\") {\r\n            // generate a useragent using a generator function\r\n            this[s_useragent] = random_useragent.getRandom(useragent);\r\n        } else if (typeof(useragent) == \"string\") {\r\n            // set useragent using supplied static string\r\n            this[s_useragent] = useragent;\r\n        } else {\r\n            throw new Error(\"Must define either static user agent string or a generator function\");\r\n        }\r\n\r\n        this.Log(\"Set useragent to \" + this.UserAgent);\r\n    }\r\n\r\n    /**\r\n     * Get this park's Timezone\r\n     * @type {String}\r\n     * */\r\n    get Timezone() {\r\n        return this[s_parkTimezone];\r\n    }\r\n\r\n    /**\r\n     * Get park's current time\r\n     * @param {Object} timeFormatObject\r\n     * @param {String} [timeFormatObject.timeFormat] Moment JS format string to format time as \r\n     * @returns {String} Time as formatted by park's timeformat, or the default timeformat if set to null\r\n     * */\r\n    TimeNow({\r\n        timeFormat = null\r\n    } = {}) {\r\n        // take time right now, convert now into park's timezone and format it\r\n        //  format in preferred order of, manually passed in format, park's default time format, or global default time format\r\n        return moment().tz(this.Timezone).format(timeFormat || this[s_parkTimeFormat] || DefaultTimeFormat);\r\n    }\r\n\r\n    /**\r\n     * Get park's current date\r\n     * @param {Object} dateFormatObject\r\n     * @param {String} [dateFormatObject.dateFormat] Moment JS format string to format date as \r\n     * @returns {String} Date as formatted by park's dateFormat, or the default dateFormat if set to null\r\n     * */\r\n    DateNow({\r\n        dateFormat = null\r\n    } = {}) {\r\n        // we're just calling the TimeNow function with a date formate string instead\r\n        return this.TimeNow({\r\n            timeFormat: dateFormat || this[s_parkDateFormat]\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the park's raw schedule object\r\n     * @returns {Schedule} Schedule object for this park's opening times\r\n     */\r\n    get Schedule() {\r\n        return this[s_scheduleData];\r\n    }\r\n\r\n    /**\r\n     * Get how many days the fetched schedule is expected to be\r\n     */\r\n    get ScheduleDays() {\r\n        return this[s_scheduleDaysToReturn];\r\n    }\r\n\r\n    /**\r\n     * Does this park offer fast-pass services?\r\n     * @type {Boolean}\r\n     */\r\n    get FastPass() {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Does this park tell you the fast-pass return times?\r\n     * @type {Boolean}\r\n     */\r\n    get FastPassReturnTimes() {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Does this park offer wait time information?\r\n     * @type {Boolean}\r\n     */\r\n    get SupportsWaitTimes() {\r\n        // base this logic solely on the presence of a function \"FetchWaitTimes\" existing\r\n        return this.FetchWaitTimes !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Does this park offer opening time information?\r\n     * @type {Boolean}\r\n     */\r\n    get SupportsOpeningTimes() {\r\n        // base this logic solely on the presence of a function \"FetchOpeningTimes\" existing\r\n        return this.FetchOpeningTimes !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Does this park offer opening times for rides?\r\n     * @type {Boolean}\r\n     */\r\n    get SupportsRideSchedules() {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Make an HTTP request using this park's user agent\r\n     */\r\n    HTTP(options) {\r\n        if (!options) return Promise.reject(\"No HTTP options passed!\");\r\n        if (!options.headers) options.headers = {};\r\n        if (!options.headers[\"User-Agent\"]) options.headers[\"User-Agent\"] = this.UserAgent;\r\n\r\n        if (!options.open_timeout) options.open_timeout = Settings.DefaultOpenTimeout;\r\n        if (!options.read_timeout) options.read_timeout = Settings.DefaultReadTimeout;\r\n\r\n        // Use proxy agent if defined in settings\r\n        if (Settings.ProxyURL) {\r\n            if (Settings.ProxyURL.startsWith(\"socks://\")) {\r\n                options.agent = new SocksProxyAgent(Settings.ProxyURL, true);\r\n            } else if (Settings.ProxyURL.startsWith(\"https://\")) {\r\n                options.agent = new HttpsProxyAgent(Settings.ProxyURL, true);\r\n            }\r\n        }\r\n\r\n        // pass on options to HTTP lib\r\n        return HTTPLib(options);\r\n    }\r\n\r\n    /**\r\n     * Get the cache object for this park\r\n     * @returns {Cache}\r\n     */\r\n    get Cache() {\r\n        return this[s_cacheObject];\r\n    }\r\n\r\n    /**\r\n     * Debug print a message (when NODE_DEBUG=themeparks is set in environment)\r\n     * @param {...*} ToPrint Objects/strings to print\r\n     * */\r\n    Log() {\r\n        return DebugLog(`${this.constructor.name}:`, ...arguments);\r\n    }\r\n}\r\n\r\n// export the Park class\r\nmodule.exports = Park;"]}