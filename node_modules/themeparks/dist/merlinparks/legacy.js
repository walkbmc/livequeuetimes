"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// include core Park class
var Park = require("../park");

var s_apiBase = Symbol();
var s_apiKey = Symbol();
var s_resortID = Symbol();

/**
 * Implements the Merlin Park API framework. Thorpe Park, Alton Towers, Chessington etc. use this API framework
 * @class
 * @extends Park
 */

var MerlinPark = function (_Park) {
    _inherits(MerlinPark, _Park);

    /**
     * Create new Merlin Object.
     * This object should not be called directly, but rather extended for each of the individual Merlin parks
     * @param {Object} options
     * @param {String} options.api_base Base URL to access the API
     * @param {String} options.api_key API key to access this park's API
     */
    function MerlinPark() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, MerlinPark);

        options.name = options.name || "Merlin Park";

        // hard-code UserAgent for these parks
        //  do this before calling super, so we don't get a randomly generated one
        options.useragent = "Apache-HttpClient/UNAVAILABLE (java 1.4)";

        // inherit from base class

        // custom API options
        var _this = _possibleConstructorReturn(this, (MerlinPark.__proto__ || Object.getPrototypeOf(MerlinPark)).call(this, options));

        if (!options.api_base) throw new Error("Merlin Parks require an API base to work");
        _this[s_apiBase] = options.api_base;
        if (!options.api_key) throw new Error("Merlin Parks require an API key");
        _this[s_apiKey] = options.api_key;

        // optional resort ID (for Chessington etc.)
        _this[s_resortID] = options.resort_id;
        return _this;
    }

    /**
     * Fetch Wait Times for Merlin Park
     */


    _createClass(MerlinPark, [{
        key: "FetchWaitTimes",
        value: function FetchWaitTimes() {
            return new Promise(function (resolve, reject) {
                // request challenge string
                this.HTTP({
                    method: "POST",
                    url: this[s_apiBase] + "/queue-times",
                    headers: {
                        "Content-Type": "application/x-www-form-urlencoded",
                        "Connection": "Keep-Alive"
                    }
                }).then(function (data) {
                    if (!data.challenge) return reject("Failed to get challenge string from API: " + JSON.stringify(data));
                    this.Log("Got challenge string " + data.challenge + " for park " + this.Name);

                    this.GenerateAPIResponse(data.challenge).then(function (response) {
                        this.Log("Generated response string " + response);

                        // make API request with our response request
                        this.HTTP({
                            method: "POST",
                            url: this[s_apiBase] + "/queue-times",
                            headers: {
                                "Content-Type": "application/x-www-form-urlencoded",
                                "Connection": "Keep-Alive"
                            },
                            body: {
                                response: response,
                                challenge: data.challenge,
                                resort: this[s_resortID] || null
                            }
                        }).then(function (waittimes) {
                            // park API results differ ever so slightly. Chessington has it under "queue-times", Alton Towers just returns an array
                            var rideData = waittimes["queue-times"] || waittimes;

                            for (var i = 0, ride; ride = rideData[i++];) {
                                var rideName = this._GetRideName(ride);
                                // skip if we have no name for this asset
                                if (!rideName) continue;

                                // apply each wait time data
                                var rideObject = this.GetRideObject({
                                    id: ride.id,
                                    name: rideName
                                });

                                if (!rideObject) {
                                    this.Log("Failed to find ride with ID " + ride.id);
                                } else {
                                    // update ride wait time
                                    rideObject.WaitTime = ride.status == "closed" ? -1 : ride.wait_time || -1;
                                }
                            }

                            resolve();
                        }.bind(this), reject);
                    }.bind(this), reject);
                }.bind(this), reject);
            }.bind(this));
        }

        /**
         * Generate a response to a challenge for this park
         * @returns {Promise<String>} Promise resolving with the challenge response for this park
         */

    }, {
        key: "GenerateAPIResponse",
        value: function GenerateAPIResponse(challenge) {
            // each park does this very slightly differently, so each park needs to implement their own version of this
            if (this._APIRespond === undefined) {
                return Promise.reject("Park needs to implement API response function _APIRespond to make API requests");
            }
            return Promise.resolve(this._APIRespond(challenge));
        }

        /**
         * The API Base URL for this park
         * @returns {String} API Base URL
         */

    }, {
        key: "APIBase",
        get: function get() {
            return this[s_apiBase];
        }

        /**
         * API Key for this park
         * @returns {String} Park's API Key
         */

    }, {
        key: "APIKey",
        get: function get() {
            return this[s_apiKey];
        }
    }]);

    return MerlinPark;
}(Park);

// export the class


module.exports = MerlinPark;
//# sourceMappingURL=legacy.js.map