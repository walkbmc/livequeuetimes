"use strict";

// include core Park class

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Park = require("../park");
var Moment = require("moment-timezone");

// uuid generation lib
var uuid = require("uuid/v4");
// zip lib to extract data
var unzip = require("yauzl");

var s_apiKey = Symbol();
var s_apiBase = Symbol();
var s_calendarURLBase = Symbol();
var s_appVersion = Symbol();
var s_appBuild = Symbol();
var s_deviceID = Symbol();
var s_dataVersion = Symbol();

var s_deviceTokenCacheTime = Symbol();
var s_userIDCacheTime = Symbol();
var s_dataCacheTime = Symbol();

/**
 * Implements the Merlin Park API framework. Thorpe Park, Alton Towers, Chessington etc. use this API framework
 * @class
 * @extends Park
 */

var MerlinPark = function (_Park) {
    _inherits(MerlinPark, _Park);

    /**
     * Create new Merlin Object.
     * This object should not be called directly, but rather extended for each of the individual Merlin parks
     * @param {Object} options
     * @param {String} options.api_key API key to access this park's API
     * @param {String} [options.api_base] API Base to use when accessing the API
     * @param {String} [options.app_build] Build version of the app (optional)
     * @param {String} [options.app_version] App version of the app (optional)
     * @param {String} [options.device_id] Device identifier for use against the API (optional)
     * @param {String} [options.initial_data_version] The initial version timestamp to fetch (optional)
     * @param {Number} [options.device_token_cachetime=86400000] Time to cache device token, in milliseconds (optional)
     * @param {Number} [options.user_id_cachetime=43200000] Time to cache user ID, in milliseconds (optional)
     * @param {Number} [options.data_cachetime=43200000] Time to ride data, in milliseconds (optional)
     */
    function MerlinPark() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, MerlinPark);

        options.name = options.name || "Merlin Park";

        // hard-code UserAgent for these parks
        //  do this before calling super, so we don't get a randomly generated one
        options.useragent = "okhttp/3.2.0";

        // inherit from base class

        // custom API options
        var _this = _possibleConstructorReturn(this, (MerlinPark.__proto__ || Object.getPrototypeOf(MerlinPark)).call(this, options));

        if (!options.api_key) throw new Error("Merlin Parks require an API key");
        _this[s_apiKey] = options.api_key;
        if (!options.initial_data_version) throw new Error("Merlin Parks require an initial data version to fetch ride names");
        _this[s_dataVersion] = options.initial_data_version;

        // app version options (optionally overriden)
        _this[s_appBuild] = options.app_build || "5";
        _this[s_appVersion] = options.app_version || "1.0.1";
        _this[s_deviceID] = options.device_id || "123";

        // default base API
        _this[s_apiBase] = options.api_base || "https://api.attractions.io/v1/";
        _this[s_calendarURLBase] = options.calendar_base || "https://www.thorpepark.com/";

        // cache times
        _this[s_deviceTokenCacheTime] = options.device_token_cachetime || 86400000; // default: 24 hours
        _this[s_userIDCacheTime] = options.user_id_cachetime || 43200000; // default: 12 hours
        _this[s_dataCacheTime] = options.data_cachetime || 43200000; // default: 12 hours
        return _this;
    }

    /**
     * Get the API Base URL
     */


    _createClass(MerlinPark, [{
        key: "FetchWaitTimes",
        value: function FetchWaitTimes() {
            var _this2 = this;

            // first, make sure we have our park data (ride names etc.)
            return this.GetParkData().then(function (rideNames) {
                // fetch wait times
                return _this2.MakeAPICall({
                    url: _this2.APIBase + "live-data"
                }).then(function (data) {
                    for (var i = 0, ride; ride = data.entities.Item.records[i++];) {
                        // apply each wait time data
                        var rideObject = _this2.GetRideObject({
                            id: ride._id,
                            name: rideNames[ride._id]
                        });

                        if (!rideObject) {
                            _this2.Log("Failed to find ride with ID " + ride.id);
                        } else {
                            // update ride wait time (wait times are in seconds in this API!)
                            rideObject.WaitTime = ride.IsOpen ? ride.QueueTime / 60 : -1;
                        }
                    }

                    return Promise.resolve();
                });
            });
        }

        /**
         * Get an API token from cache or through registering a new device
         */

    }, {
        key: "RegisterDevice",
        value: function RegisterDevice() {
            var _this3 = this;

            // fetch new device token if we haven't already got one in our cache
            return this.Cache.Wrap("device_token", function () {
                // first, get (or generate) a new user ID
                return _this3.GenerateUserID().then(function (user_id) {
                    // request token for further API requests
                    return _this3.HTTP({
                        url: _this3[s_apiBase] + "installation",
                        method: "POST",
                        data: {
                            user_identifier: user_id,
                            device_identifier: _this3[s_deviceID],
                            app_version: _this3[s_appVersion],
                            app_build: _this3[s_appBuild]
                        },
                        headers: {
                            "occasio-platform": "Android",
                            "occasio-platform-version": "6.0.1",
                            "occasio-app-build": _this3[s_appBuild],
                            "authorization": "Attractions-Io api-key \"" + _this3[s_apiKey] + "\""
                        }
                    }).then(function (data) {
                        if (data && data.token) {
                            return Promise.resolve(data.token);
                        }

                        return Promise.reject("No data returned");
                    });
                });
            }, this[s_deviceTokenCacheTime]);
        }

        /**
         * Generate (or fetch a cached) user ID
         */

    }, {
        key: "GenerateUserID",
        value: function GenerateUserID() {
            var _this4 = this;

            return this.Cache.Wrap("user_id", function () {
                // generate new UUID if cache hit fails
                var newUserID = uuid();

                _this4.Log("Generated new UserID " + newUserID);

                return Promise.resolve(newUserID);
            }, this[s_userIDCacheTime]);
        }

        /**
         * Get (or fetch new) park data
         */

    }, {
        key: "GetParkData",
        value: function GetParkData() {
            var _this5 = this;

            return this.Cache.Wrap("data", function () {
                // fetch fresh/updated data
                return _this5.FetchParkData(_this5.DataVersion).then(function (data) {
                    var rideData = {};
                    for (var i = 0, item; item = data.Item[i++];) {
                        rideData[item._id] = item.Name;
                    }
                    return Promise.resolve(rideData);
                });
            }, this[s_dataCacheTime]);
        }

        /**
         * Get the latest data version timestamp
         */

    }, {
        key: "FetchParkData",


        /**
         * Fetch/Sync park data
         * Warning: full sync is ~30MB
         */
        value: function FetchParkData(version) {
            var _this6 = this;

            // this is a recursive function, and will keep fetching data until we get no more deltas to resolve
            //  note: we should attempt to periodically update the initialVersion to cut down on these requests

            // remember this as the latest version for next fetch
            this[s_dataVersion] = version;

            // Fetch data
            return this.MakeAPICall({
                url: this[s_apiBase] + "data",
                data: {
                    version: version
                },
                // we want the full response to get the status code
                returnFullResponse: true
            }).then(function (response) {
                if (response.statusCode == 304) {
                    // reject
                    _this6.Log("Reached status 304 accessing data version " + version);
                    return Promise.reject();
                } else {
                    _this6.Log("Received data for version " + version);

                    return new Promise(function (resolve, reject) {
                        // unzip data
                        unzip.fromBuffer(response.body, {
                            lazyEntries: true
                        }, function (err, zip) {
                            var manifestData;
                            var recordsData;

                            _this6.Log("Parsing zip file");
                            if (err) {
                                return reject(err);
                            }

                            var GetNextEntry = function GetNextEntry() {
                                if (manifestData && recordsData) {
                                    // got both the files we need, stop reading the zip file

                                    // fetch next data URL
                                    if (manifestData.version) {
                                        _this6.FetchParkData(manifestData.version).catch(function () {
                                            // as soon as we hit an error, return the current level or records data
                                            return resolve(recordsData);
                                        });
                                    } else {
                                        return resolve(recordsData);
                                    }
                                } else {
                                    // read next entry
                                    zip.readEntry();
                                }
                            };

                            zip.on("entry", function (file) {
                                _this6.Log("Got zip file " + file.fileName);

                                // look for the two files we want
                                if (file.fileName == "manifest.json") {
                                    ReadZipFile(zip, file).then(function (data) {
                                        manifestData = data;

                                        GetNextEntry();
                                    });
                                } else if (file.fileName == "records.json") {
                                    ReadZipFile(zip, file).then(function (data) {
                                        recordsData = data;

                                        GetNextEntry();
                                    });
                                } else {
                                    GetNextEntry();
                                }
                            });

                            // start reading file...
                            zip.readEntry();
                        });
                    });
                }
            });
        }

        /**
         * Generic API request function, will sort out API token and send auth headers
         * @param {*} options 
         * @param {String} options.url URL to access
         * @param {String} [options.method=GET] method to use
         * @param {Object} [options.data={}] data/query string to use
         */

    }, {
        key: "MakeAPICall",
        value: function MakeAPICall() {
            var _this7 = this;

            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
                method: "GET",
                data: {}
            };

            // get token
            return this.RegisterDevice().then(function (token) {
                // inject auth headers into request headers
                if (!options.headers) {
                    options.headers = {};
                }
                options.headers["occasio-platform"] = "Android";
                options.headers["occasio-platform-version"] = "6.0.1";
                options.headers["occasio-app-build"] = _this7[s_appBuild];
                options.headers["authorization"] = "Attractions-Io api-key \"" + _this7[s_apiKey] + "\", installation-token=\"" + token + "\"";

                // make API call
                return _this7.HTTP(options);
            });
        }
    }, {
        key: "FetchOpeningTimes",
        value: function FetchOpeningTimes() {
            var _this8 = this;

            return new Promise(function (resolve, reject) {
                _this8.HTTP({
                    url: _this8[s_calendarURLBase] + "Umbraco/Api/Calendar/GetAllOpeningTimes",
                    method: "GET",
                    headers: {
                        "Referer": _this8[s_calendarURLBase],
                        "X-Requested-With": "XMLHttpRequest"
                    },
                    json: true
                }).then(function (calendarData) {
                    // find theme park dates from response
                    //  it contains "WatterPark"[sic] times as well in a separate array
                    var parkDates = null;
                    if (calendarData[0] && calendarData[0].Type) {
                        // for resorts with multiple parks (Alton Towers)
                        for (var i = 0, times; times = calendarData[i++];) {
                            if (times.Type == "ThemePark") {
                                parkDates = times.OpeningHours;
                                break;
                            }
                        }
                    } else if (calendarData[0].Open) {
                        // resorts with only 1 park (Thorpe Park)
                        parkDates = calendarData;
                    } else {
                        return reject("Invalid/Unknown calendar data returned");
                    }

                    var result, timeRange;
                    for (i = 0, timeRange; timeRange = parkDates[i++];) {
                        var range = {
                            startDate: Moment(timeRange.From, "YYYY-MM-DDTHH:mm:ss"),
                            endDate: Moment(timeRange.To, "YYYY-MM-DDTHH:mm:ss")
                        };

                        _this8.Log("Processing " + range.startDate + " => " + range.endDate);

                        // figure out opening times for this range
                        if (result = /([0-9:]+\s?[ap]m)\s*-\s*([0-9:]+\s?[ap]m)/gi.exec(timeRange.Open.replace(/\./g, ":"))) {
                            range.openingTime = Moment(result[1].replace(/ /g, ""), "HH:mma");
                            range.closingTime = Moment(result[2].replace(/ /g, ""), "HH:mma");
                        }
                        // try shorthand format too, in case someone entered the times in badly
                        else if (result = /([0-9]+)\s*-\s*([0-9]+)/gi.exec(timeRange.Open.replace(/\./g, ":"))) {
                                range.openingTime = Moment(result[1] + ":00am", "HH:mma");
                                range.closingTime = Moment(result[2] + ":00pm", "HH:mma");
                            } else {
                                _this8.Log("Unable to understand hour format: " + timeRange.Open);
                                continue;
                            }

                        // apply this range
                        _this8.Schedule.SetRange(range);
                    }

                    resolve();
                }, reject);
            });
        }
    }, {
        key: "APIBase",
        get: function get() {
            return this[s_apiBase];
        }
    }, {
        key: "DataVersion",
        get: function get() {
            return this[s_dataVersion];
        }
    }]);

    return MerlinPark;
}(Park);

// export the class


module.exports = MerlinPark;

// static functions
function ReadZipFile(zip, file) {
    return new Promise(function (resolve, reject) {
        var data = "";
        zip.openReadStream(file, function (err, readStream) {
            if (err) {
                return reject(err);
            }

            readStream.on("data", function (chunk) {
                data += chunk;
            }).on("end", function () {
                // parse JSON data
                try {
                    data = JSON.parse(data);
                    return resolve(data);
                } catch (e) {
                    return reject("JSON parse error extracting " + file.fileName + ": " + e);
                }
            });
        });
    });
}
//# sourceMappingURL=index.js.map