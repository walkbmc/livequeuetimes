{"version":3,"sources":["../../lib/merlinparks/index.js"],"names":["Park","require","Moment","uuid","unzip","s_apiKey","Symbol","s_apiBase","s_calendarURLBase","s_appVersion","s_appBuild","s_deviceID","s_dataVersion","s_deviceTokenCacheTime","s_userIDCacheTime","s_dataCacheTime","MerlinPark","options","name","useragent","api_key","Error","initial_data_version","app_build","app_version","device_id","api_base","calendar_base","device_token_cachetime","user_id_cachetime","data_cachetime","GetParkData","then","rideNames","MakeAPICall","url","APIBase","data","i","ride","entities","Item","records","rideObject","GetRideObject","id","_id","Log","WaitTime","IsOpen","QueueTime","Promise","resolve","Cache","Wrap","GenerateUserID","user_id","HTTP","method","user_identifier","device_identifier","headers","token","reject","newUserID","FetchParkData","DataVersion","rideData","item","Name","version","returnFullResponse","response","statusCode","fromBuffer","body","lazyEntries","err","zip","manifestData","recordsData","GetNextEntry","catch","readEntry","on","file","fileName","ReadZipFile","RegisterDevice","json","calendarData","parkDates","Type","times","OpeningHours","Open","result","timeRange","range","startDate","From","endDate","To","exec","replace","openingTime","closingTime","Schedule","SetRange","module","exports","openReadStream","readStream","chunk","JSON","parse","e"],"mappings":"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","file":"index.js","sourcesContent":["\"use strict\";\r\n\r\n// include core Park class\r\nconst Park = require(\"../park\");\r\nconst Moment = require(\"moment-timezone\");\r\n\r\n// uuid generation lib\r\nconst uuid = require(\"uuid/v4\");\r\n// zip lib to extract data\r\nconst unzip = require(\"yauzl\");\r\n\r\nconst s_apiKey = Symbol();\r\nconst s_apiBase = Symbol();\r\nconst s_calendarURLBase = Symbol();\r\nconst s_appVersion = Symbol();\r\nconst s_appBuild = Symbol();\r\nconst s_deviceID = Symbol();\r\nconst s_dataVersion = Symbol();\r\n\r\nconst s_deviceTokenCacheTime = Symbol();\r\nconst s_userIDCacheTime = Symbol();\r\nconst s_dataCacheTime = Symbol();\r\n\r\n/**\r\n * Implements the Merlin Park API framework. Thorpe Park, Alton Towers, Chessington etc. use this API framework\r\n * @class\r\n * @extends Park\r\n */\r\nclass MerlinPark extends Park {\r\n    /**\r\n     * Create new Merlin Object.\r\n     * This object should not be called directly, but rather extended for each of the individual Merlin parks\r\n     * @param {Object} options\r\n     * @param {String} options.api_key API key to access this park's API\r\n     * @param {String} [options.api_base] API Base to use when accessing the API\r\n     * @param {String} [options.app_build] Build version of the app (optional)\r\n     * @param {String} [options.app_version] App version of the app (optional)\r\n     * @param {String} [options.device_id] Device identifier for use against the API (optional)\r\n     * @param {String} [options.initial_data_version] The initial version timestamp to fetch (optional)\r\n     * @param {Number} [options.device_token_cachetime=86400000] Time to cache device token, in milliseconds (optional)\r\n     * @param {Number} [options.user_id_cachetime=43200000] Time to cache user ID, in milliseconds (optional)\r\n     * @param {Number} [options.data_cachetime=43200000] Time to ride data, in milliseconds (optional)\r\n     */\r\n    constructor(options = {}) {\r\n        options.name = options.name || \"Merlin Park\";\r\n\r\n        // hard-code UserAgent for these parks\r\n        //  do this before calling super, so we don't get a randomly generated one\r\n        options.useragent = \"okhttp/3.2.0\";\r\n\r\n        // inherit from base class\r\n        super(options);\r\n\r\n        // custom API options\r\n        if (!options.api_key) throw new Error(\"Merlin Parks require an API key\");\r\n        this[s_apiKey] = options.api_key;\r\n        if (!options.initial_data_version) throw new Error(\"Merlin Parks require an initial data version to fetch ride names\");\r\n        this[s_dataVersion] = options.initial_data_version;\r\n\r\n        // app version options (optionally overriden)\r\n        this[s_appBuild] = options.app_build || \"5\";\r\n        this[s_appVersion] = options.app_version || \"1.0.1\";\r\n        this[s_deviceID] = options.device_id || \"123\";\r\n\r\n        // default base API\r\n        this[s_apiBase] = options.api_base || \"https://api.attractions.io/v1/\";\r\n        this[s_calendarURLBase] = options.calendar_base || \"https://www.thorpepark.com/\";\r\n\r\n        // cache times\r\n        this[s_deviceTokenCacheTime] = options.device_token_cachetime || 86400000; // default: 24 hours\r\n        this[s_userIDCacheTime] = options.user_id_cachetime || 43200000; // default: 12 hours\r\n        this[s_dataCacheTime] = options.data_cachetime || 43200000; // default: 12 hours\r\n    }\r\n\r\n    /**\r\n     * Get the API Base URL\r\n     */\r\n    get APIBase() {\r\n        return this[s_apiBase];\r\n    }\r\n\r\n    FetchWaitTimes() {\r\n        // first, make sure we have our park data (ride names etc.)\r\n        return this.GetParkData().then((rideNames) => {\r\n            // fetch wait times\r\n            return this.MakeAPICall({\r\n                url: `${this.APIBase}live-data`\r\n            }).then((data) => {\r\n                for (var i = 0, ride; ride = data.entities.Item.records[i++];) {\r\n                    // apply each wait time data\r\n                    var rideObject = this.GetRideObject({\r\n                        id: ride._id,\r\n                        name: rideNames[ride._id],\r\n                    });\r\n\r\n                    if (!rideObject) {\r\n                        this.Log(`Failed to find ride with ID ${ride.id}`);\r\n                    } else {\r\n                        // update ride wait time (wait times are in seconds in this API!)\r\n                        rideObject.WaitTime = ride.IsOpen ? (ride.QueueTime / 60) : -1;\r\n                    }\r\n                }\r\n\r\n                return Promise.resolve();\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get an API token from cache or through registering a new device\r\n     */\r\n    RegisterDevice() {\r\n        // fetch new device token if we haven't already got one in our cache\r\n        return this.Cache.Wrap(\"device_token\", () => {\r\n            // first, get (or generate) a new user ID\r\n            return this.GenerateUserID().then((user_id) => {\r\n                // request token for further API requests\r\n                return this.HTTP({\r\n                    url: `${this[s_apiBase]}installation`,\r\n                    method: \"POST\",\r\n                    data: {\r\n                        user_identifier: user_id,\r\n                        device_identifier: this[s_deviceID],\r\n                        app_version: this[s_appVersion],\r\n                        app_build: this[s_appBuild]\r\n                    },\r\n                    headers: {\r\n                        \"occasio-platform\": \"Android\",\r\n                        \"occasio-platform-version\": \"6.0.1\",\r\n                        \"occasio-app-build\": this[s_appBuild],\r\n                        \"authorization\": `Attractions-Io api-key \"${this[s_apiKey]}\"`,\r\n                    }\r\n                }).then((data) => {\r\n                    if (data && data.token) {\r\n                        return Promise.resolve(data.token);\r\n                    }\r\n\r\n                    return Promise.reject(\"No data returned\");\r\n                });\r\n            });\r\n        }, this[s_deviceTokenCacheTime]);\r\n    }\r\n\r\n    /**\r\n     * Generate (or fetch a cached) user ID\r\n     */\r\n    GenerateUserID() {\r\n        return this.Cache.Wrap(\"user_id\", () => {\r\n            // generate new UUID if cache hit fails\r\n            const newUserID = uuid();\r\n\r\n            this.Log(`Generated new UserID ${newUserID}`);\r\n\r\n            return Promise.resolve(newUserID);\r\n        }, this[s_userIDCacheTime]);\r\n    }\r\n\r\n    /**\r\n     * Get (or fetch new) park data\r\n     */\r\n    GetParkData() {\r\n        return this.Cache.Wrap(\"data\", () => {\r\n            // fetch fresh/updated data\r\n            return this.FetchParkData(this.DataVersion).then((data) => {\r\n                var rideData = {};\r\n                for (var i = 0, item; item = data.Item[i++];) {\r\n                    rideData[item._id] = item.Name;\r\n                }\r\n                return Promise.resolve(rideData);\r\n            });\r\n        }, this[s_dataCacheTime]);\r\n    }\r\n\r\n    /**\r\n     * Get the latest data version timestamp\r\n     */\r\n    get DataVersion() {\r\n        return this[s_dataVersion];\r\n    }\r\n\r\n    /**\r\n     * Fetch/Sync park data\r\n     * Warning: full sync is ~30MB\r\n     */\r\n    FetchParkData(version) {\r\n        // this is a recursive function, and will keep fetching data until we get no more deltas to resolve\r\n        //  note: we should attempt to periodically update the initialVersion to cut down on these requests\r\n\r\n        // remember this as the latest version for next fetch\r\n        this[s_dataVersion] = version;\r\n\r\n        // Fetch data\r\n        return this.MakeAPICall({\r\n            url: `${this[s_apiBase]}data`,\r\n            data: {\r\n                version: version\r\n            },\r\n            // we want the full response to get the status code\r\n            returnFullResponse: true,\r\n        }).then((response) => {\r\n            if (response.statusCode == 304) {\r\n                // reject\r\n                this.Log(`Reached status 304 accessing data version ${version}`);\r\n                return Promise.reject();\r\n            } else {\r\n                this.Log(`Received data for version ${version}`);\r\n\r\n                return new Promise((resolve, reject) => {\r\n                    // unzip data\r\n                    unzip.fromBuffer(response.body, {\r\n                        lazyEntries: true\r\n                    }, (err, zip) => {\r\n                        var manifestData;\r\n                        var recordsData;\r\n\r\n                        this.Log(\"Parsing zip file\");\r\n                        if (err) {\r\n                            return reject(err);\r\n                        }\r\n\r\n                        const GetNextEntry = () => {\r\n                            if (manifestData && recordsData) {\r\n                                // got both the files we need, stop reading the zip file\r\n\r\n                                // fetch next data URL\r\n                                if (manifestData.version) {\r\n                                    this.FetchParkData(manifestData.version).catch(() => {\r\n                                        // as soon as we hit an error, return the current level or records data\r\n                                        return resolve(recordsData);\r\n                                    });\r\n                                } else {\r\n                                    return resolve(recordsData);\r\n                                }\r\n                            } else {\r\n                                // read next entry\r\n                                zip.readEntry();\r\n                            }\r\n                        };\r\n\r\n                        zip.on(\"entry\", (file) => {\r\n                            this.Log(`Got zip file ${file.fileName}`);\r\n\r\n                            // look for the two files we want\r\n                            if (file.fileName == \"manifest.json\") {\r\n                                ReadZipFile(zip, file).then((data) => {\r\n                                    manifestData = data;\r\n\r\n                                    GetNextEntry();\r\n                                });\r\n                            } else if (file.fileName == \"records.json\") {\r\n                                ReadZipFile(zip, file).then((data) => {\r\n                                    recordsData = data;\r\n\r\n                                    GetNextEntry();\r\n                                });\r\n                            } else {\r\n                                GetNextEntry();\r\n                            }\r\n                        });\r\n\r\n                        // start reading file...\r\n                        zip.readEntry();\r\n                    });\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generic API request function, will sort out API token and send auth headers\r\n     * @param {*} options \r\n     * @param {String} options.url URL to access\r\n     * @param {String} [options.method=GET] method to use\r\n     * @param {Object} [options.data={}] data/query string to use\r\n     */\r\n    MakeAPICall(options = {\r\n        method: \"GET\",\r\n        data: {}\r\n    }) {\r\n        // get token\r\n        return this.RegisterDevice().then((token) => {\r\n            // inject auth headers into request headers\r\n            if (!options.headers) {\r\n                options.headers = {};\r\n            }\r\n            options.headers[\"occasio-platform\"] = \"Android\";\r\n            options.headers[\"occasio-platform-version\"] = \"6.0.1\";\r\n            options.headers[\"occasio-app-build\"] = this[s_appBuild];\r\n            options.headers[\"authorization\"] = `Attractions-Io api-key \"${this[s_apiKey]}\", installation-token=\"${token}\"`;\r\n\r\n            // make API call\r\n            return this.HTTP(options);\r\n        });\r\n    }\r\n\r\n    FetchOpeningTimes() {\r\n        return new Promise((resolve, reject) => {\r\n            this.HTTP({\r\n                url: `${this[s_calendarURLBase]}Umbraco/Api/Calendar/GetAllOpeningTimes`,\r\n                method: \"GET\",\r\n                headers: {\r\n                    \"Referer\": this[s_calendarURLBase],\r\n                    \"X-Requested-With\": \"XMLHttpRequest\",\r\n                },\r\n                json: true\r\n            }).then((calendarData) => {\r\n                // find theme park dates from response\r\n                //  it contains \"WatterPark\"[sic] times as well in a separate array\r\n                var parkDates = null;\r\n                if (calendarData[0] && calendarData[0].Type) {\r\n                    // for resorts with multiple parks (Alton Towers)\r\n                    for (var i = 0, times; times = calendarData[i++];) {\r\n                        if (times.Type == \"ThemePark\") {\r\n                            parkDates = times.OpeningHours;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else if (calendarData[0].Open) {\r\n                    // resorts with only 1 park (Thorpe Park)\r\n                    parkDates = calendarData;\r\n                } else {\r\n                    return reject(\"Invalid/Unknown calendar data returned\");\r\n                }\r\n\r\n                var result, timeRange;\r\n                for (i = 0, timeRange; timeRange = parkDates[i++];) {\r\n                    var range = {\r\n                        startDate: Moment(timeRange.From, \"YYYY-MM-DDTHH:mm:ss\"),\r\n                        endDate: Moment(timeRange.To, \"YYYY-MM-DDTHH:mm:ss\")\r\n                    };\r\n\r\n                    this.Log(`Processing ${range.startDate} => ${range.endDate}`);\r\n\r\n                    // figure out opening times for this range\r\n                    if (result = /([0-9:]+\\s?[ap]m)\\s*-\\s*([0-9:]+\\s?[ap]m)/gi.exec(timeRange.Open.replace(/\\./g, \":\"))) {\r\n                        range.openingTime = Moment(result[1].replace(/ /g, \"\"), \"HH:mma\");\r\n                        range.closingTime = Moment(result[2].replace(/ /g, \"\"), \"HH:mma\");\r\n                    }\r\n                    // try shorthand format too, in case someone entered the times in badly\r\n                    else if (result = /([0-9]+)\\s*-\\s*([0-9]+)/gi.exec(timeRange.Open.replace(/\\./g, \":\"))) {\r\n                        range.openingTime = Moment(result[1] + \":00am\", \"HH:mma\");\r\n                        range.closingTime = Moment(result[2] + \":00pm\", \"HH:mma\");\r\n                    } else {\r\n                        this.Log(`Unable to understand hour format: ${timeRange.Open}`);\r\n                        continue;\r\n                    }\r\n\r\n                    // apply this range\r\n                    this.Schedule.SetRange(range);\r\n                }\r\n\r\n                resolve();\r\n            }, reject);\r\n        });\r\n    }\r\n}\r\n\r\n// export the class\r\nmodule.exports = MerlinPark;\r\n\r\n// static functions\r\nfunction ReadZipFile(zip, file) {\r\n    return new Promise((resolve, reject) => {\r\n        var data = \"\";\r\n        zip.openReadStream(file, function(err, readStream) {\r\n            if (err) {\r\n                return reject(err);\r\n            }\r\n\r\n            readStream.on(\"data\", function(chunk) {\r\n                data += chunk;\r\n            }).on(\"end\", function() {\r\n                // parse JSON data\r\n                try {\r\n                    data = JSON.parse(data);\r\n                    return resolve(data);\r\n                } catch (e) {\r\n                    return reject(`JSON parse error extracting ${file.fileName}: ${e}`);\r\n                }\r\n            });\r\n        });\r\n    });\r\n}"]}