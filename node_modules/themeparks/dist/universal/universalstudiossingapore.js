"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// include core Park class
var Park = require("../park");

var GeoLocation = require("../geoLocation");

var cheerio = require("cheerio");
var Moment = require("moment-timezone");

var s_APIBase = Symbol();
var s_APILanguage = Symbol();
var s_parkLocationMin = Symbol();
var s_parkLocationMax = Symbol();
var s_parkScheduleURL = Symbol();

/**
 * Implements the Universal Singapore API.
 * @class
 * @extends Park
 */

var UniversalStudiosSingapore = function (_Park) {
    _inherits(UniversalStudiosSingapore, _Park);

    /**
     * Create new UniversalStudiosSingapore Object.
     * @param {Object} options
     * @param {String} [options.api_base] API URL base for accessing API
     * @param {String} [options.api_langauge] Language ID for API results (default: 1)
     */
    function UniversalStudiosSingapore() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, UniversalStudiosSingapore);

        options.name = options.name || "Universal Studios Singapore";

        // set park's location as it's entrance
        options.latitude = options.latitude || 1.254251;
        options.longitude = options.longitude || 103.823797;

        options.timezone = "Asia/Singapore";

        // inherit from base class

        var _this = _possibleConstructorReturn(this, (UniversalStudiosSingapore.__proto__ || Object.getPrototypeOf(UniversalStudiosSingapore)).call(this, options));

        _this[s_APIBase] = options.api_base || "http://cma.rwsentosa.com/Service.svc/GetUSSContent";
        _this[s_APILanguage] = options.api_langauge || 1;
        _this[s_parkScheduleURL] = options.schedule_url || "http://www.rwsentosa.com/Homepage/Attractions/UniversalStudiosSingapore";

        // Geofence corners (to generate random location for API requests)
        _this[s_parkLocationMin] = new GeoLocation({
            latitude: 1.2547872658731591,
            longitude: 103.8217341899872
        });
        _this[s_parkLocationMax] = new GeoLocation({
            latitude: 1.2533177673892697,
            longitude: 103.82408380508424
        });
        return _this;
    }

    /**
     * Fetch Universal Singapore's waiting times
     * @returns {Promise}
     */


    _createClass(UniversalStudiosSingapore, [{
        key: "FetchWaitTimes",
        value: function FetchWaitTimes() {
            var _this2 = this;

            return new Promise(function (resolve, reject) {
                // generate random geo location to fetch with
                var randomGeoLocation = GeoLocation.RandomBetween(_this2[s_parkLocationMin], _this2[s_parkLocationMax]);

                _this2.Log("Running Universal Studios Singapore");
                _this2.HTTP({
                    url: _this2[s_APIBase],
                    body: {
                        "languageID": _this2[s_APILanguage],
                        "filter": "Ride",
                        "Latitude": randomGeoLocation.LatitudeRaw,
                        "Longitude": randomGeoLocation.LongitudeRaw
                    }
                }).then(function (body) {
                    // check the response is as we expect
                    if (!body || !body.ResponseOfUSS || !body.ResponseOfUSS.Result || !body.ResponseOfUSS.Result.USSZoneList || !body.ResponseOfUSS.Result.USSZoneList.USSZone) {
                        _this2.Log("Error parsing Universal Studios Singapore response: " + body);
                        return reject("Unable to parse Universal Studios Singapore wait times response");
                    }

                    // loop through each zone
                    body.ResponseOfUSS.Result.USSZoneList.USSZone.forEach(function (zone) {
                        var rides = zone.Content.USSContent;

                        // loop through each ride
                        for (var rideIDX = 0, ride; ride = rides[rideIDX++];) {
                            var rideObject = _this2.GetRideObject({
                                id: ride.USSContentID,
                                name: ride.Name
                            });

                            rideObject.WaitTime = ride.Availability && ride.Availability == "True" ? parseInt(ride.QueueTime, 10) || -1 : -1;
                        }
                    });

                    return resolve();
                }, reject);
            });
        }
    }, {
        key: "FetchOpeningTimes",
        value: function FetchOpeningTimes() {
            var _this3 = this;

            // Get HTML page of park
            return this.HTTP({
                url: this[s_parkScheduleURL]
            }).then(this.ParseOpeningHoursHTML.bind(this)).then(function (results) {
                // parse results
                for (var dateIdx = 0, date; date = results[dateIdx++];) {
                    // record results
                    _this3.Schedule.SetDate({
                        date: date.OpeningHour,
                        openingTime: date.OpeningHour,
                        closingTime: date.ClosingHour
                    });
                }
                return Promise.resolve();
            });
        }
    }, {
        key: "ParseOpeningHoursHTML",
        value: function ParseOpeningHoursHTML(HTML) {
            var $ = cheerio.load(HTML);

            var results = [];

            // grab all the styled tables (a potential calendar)
            var tables = $("table.styled");
            for (var tableIdx = 0, table; table = tables[tableIdx++];) {
                table = $(table);
                // check we found a calendar month (otherwise it's some other table on this page)
                var month = table.find(".tableTitle").text();
                // validate using Moment
                if (Moment(month, "MMMM YYYY").isValid()) {
                    // find each table cell
                    var dates = table.find("td");
                    for (var i = 0, date; date = dates[i++];) {
                        date = $(date);
                        // check it has a valid date (and not an empty cell!)
                        var dateString = date.find("strong").text();
                        var dateVal = parseInt(dateString, 10);
                        if (dateVal > 0) {
                            // slim down hours to remove all whitespace
                            //  leave in newlines, so we can ignore the special parades/hours
                            var dateHours = date.find("span").last().text().trim().replace(/[^\S\n]/g, "");

                            // look for valid times
                            var match = /([0-9]+[AP]M)-([0-9]+[AP]M)/.exec(dateHours);
                            if (match && match[1] && match[2]) {
                                var OpeningHour = Moment.tz(dateVal + " " + month + " " + match[1], "D MMMM YYYY HA", this.Timezone);
                                var ClosingHour = Moment.tz(dateVal + " " + month + " " + match[2], "D MMMM YYYY HA", this.Timezone);

                                results.push({
                                    OpeningHour: OpeningHour,
                                    ClosingHour: ClosingHour
                                });
                            }
                        }
                    }
                }
            }

            return Promise.resolve(results);
        }
    }]);

    return UniversalStudiosSingapore;
}(Park);

// export the class


module.exports = UniversalStudiosSingapore;
//# sourceMappingURL=universalstudiossingapore.js.map