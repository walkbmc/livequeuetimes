{"version":3,"sources":["../lib/schedule.js"],"names":["Log","require","moment","settings","s_scheduleDates","Symbol","s_scheduleDatesSpecial","s_scheduleDateFormat","s_scheduleTimeFormat","s_scheduleIsDirty","Schedule","dateFormat","timeFormat","Map","DefaultDateFormat","DefaultTimeFormat","dates","datesSpecial","scheduleData","date","openingTime","closingTime","specialHours","type","parseDateTime","startOf","endOf","day","dateToDay","todaySet","year","month","set","isBefore","add","newScheduleData","format","has","checkDirtyObj","get","IsDirty","newSpecialScheduleData","newDataStringified","JSON","stringify","specialDayArray","i","checkData","push","startDate","endDate","retValue","m","isSameOrBefore","SetDate","dayData","returnObject","special","returnArray","dateSchedule","GetDate","value","dateObject","varName","isMoment","newDate","ISO_8601","isValid","Math","floor","unix","utcOffset","module","exports"],"mappings":"AAAA;;;;;;AAEA,IAAIA,MAAMC,QAAQ,cAAR,CAAV;AACA,IAAIC,SAASD,QAAQ,iBAAR,CAAb;AACA,IAAIE,WAAWF,QAAQ,YAAR,CAAf;;AAEA,IAAIG,kBAAkBC,QAAtB;AACA,IAAIC,yBAAyBD,QAA7B;AACA,IAAIE,uBAAuBF,QAA3B;AACA,IAAIG,uBAAuBH,QAA3B;AACA,IAAII,oBAAoBJ,QAAxB;;AAEA;;;;;;;;;;AAUA;;;;;;;;AAQA;;;;;;IAKMK,Q;AACF;;;;;;AAMA,wBAGQ;AAAA,uFAAJ,EAAI;AAAA,mCAFJC,UAEI;AAAA,YAFJA,UAEI,mCAFS,IAET;AAAA,mCADJC,UACI;AAAA,YADJA,UACI,mCADS,IACT;;AAAA;;AACJ;AACA;AACA,aAAKR,eAAL,IAAwB,IAAIS,GAAJ,EAAxB;AACA;AACA,aAAKP,sBAAL,IAA+B,IAAIO,GAAJ,EAA/B;AACA;AACA,aAAKN,oBAAL,IAA6BI,cAAcR,SAASW,iBAApD;AACA;AACA,aAAKN,oBAAL,IAA6BI,cAAcT,SAASY,iBAApD;;AAEA;AACA,aAAKN,iBAAL,IAA0B,KAA1B;AACH;;AAED;;;;;;;;iCAIS;AACL,mBAAO;AACHO,uBAAO,KAAKZ,eAAL,CADJ;AAEHa,8BAAc,KAAKX,sBAAL;AAFX,aAAP;AAIH;;AAED;;;;;;;iCAISY,Y,EAAc;AACnB,iBAAKd,eAAL,IAAwBc,aAAaF,KAArC;AACA,iBAAKV,sBAAL,IAA+BY,aAAaD,YAA5C;AACH;;AAED;;;;;;;;;AAgBA;;;;;;;;;;uCAqBG;AAAA,mCATCE,IASD;AAAA,gBATCA,IASD,8BATQ,IASR;AAAA,0CAPCC,WAOD;AAAA,gBAPCA,WAOD,qCAPe,IAOf;AAAA,0CALCC,WAKD;AAAA,gBALCA,WAKD,qCALe,IAKf;AAAA,2CAHCC,YAGD;AAAA,gBAHCA,YAGD,sCAHgB,KAGhB;AAAA,mCADCC,IACD;AAAA,gBADCA,IACD,8BADQ,WACR;;AACC;AACA,gBAAI,CAACJ,IAAL,EAAWA,OAAOC,WAAP;;AAEX;AACAD,mBAAOK,cAAcL,IAAd,EAAoB,MAApB,CAAP;;AAEA;AACA,gBAAII,QAAQ,QAAZ,EAAsB;AAClB,oBAAI,CAACH,WAAL,EAAkBA,cAAcD,KAAKM,OAAL,CAAa,KAAb,CAAd;AAClB,oBAAI,CAACJ,WAAL,EAAkBA,cAAcF,KAAKO,KAAL,CAAW,KAAX,CAAd;AACrB;;AAEDN,0BAAcI,cAAcJ,WAAd,EAA2B,aAA3B,CAAd;AACAC,0BAAcG,cAAcH,WAAd,EAA2B,aAA3B,CAAd;;AAEA;AACA,gBAAI,CAACF,IAAD,IAAS,CAACC,WAAV,IAAyB,CAACC,WAA9B,EAA2C,OAAO,KAAP;;AAE3C;AACA,gBAAIM,MAAMC,UAAUT,IAAV,CAAV;;AAEA;AACA,gBAAIU,WAAW;AACX,wBAAQV,KAAKW,IAAL,EADG;AAEX,yBAASX,KAAKY,KAAL,EAFE;AAGX,wBAAQZ,KAAKA,IAAL;AAHG,aAAf;AAKAC,wBAAYY,GAAZ,CAAgBH,QAAhB;AACAR,wBAAYW,GAAZ,CAAgBH,QAAhB;;AAEA;AACA,gBAAIR,YAAYY,QAAZ,CAAqBb,WAArB,CAAJ,EAAuC;AACnC;AACAC,4BAAYa,GAAZ,CAAgB,CAAhB,EAAmB,KAAnB;AACH;;AAED;AACA,gBAAI,CAACZ,YAAL,EAAmB;AACf;AACA,oBAAIC,QAAQ,WAAR,IAAuBA,QAAQ,QAA/B,IAA2CA,QAAQ,eAAvD,EAAwE;AACpEvB,gEAA0CuB,IAA1C;AACA,2BAAO,KAAP;AACH;;AAED,oBAAIY,kBAAkB;AAClB,4BAAQhB,KAAKiB,MAAL,CAAY,KAAK7B,oBAAL,CAAZ,CADU;AAElB,mCAAea,YAAYgB,MAAZ,CAAmB,KAAK5B,oBAAL,CAAnB,CAFG;AAGlB,mCAAea,YAAYe,MAAZ,CAAmB,KAAK5B,oBAAL,CAAnB,CAHG;AAIlB,4BAAQe;AAJU,iBAAtB;;AAOA;AACA,oBAAI,KAAKnB,eAAL,EAAsBiC,GAAtB,CAA0BV,GAA1B,CAAJ,EAAoC;AAChC,wBAAIW,gBAAgB,KAAKlC,eAAL,EAAsBmC,GAAtB,CAA0BZ,GAA1B,CAApB;AACA,wBACIW,cAAcnB,IAAd,IAAsBgB,gBAAgBhB,IAAtC,IACAmB,cAAclB,WAAd,IAA6Be,gBAAgBf,WAD7C,IAEAkB,cAAcjB,WAAd,IAA6Bc,gBAAgBd,WAF7C,IAGAiB,cAAcf,IAAd,IAAsBY,gBAAgBZ,IAJ1C,EAIgD;AAC5C;AACA,+BAAO,KAAP;AACH;AACJ;;AAED;AACA,qBAAKnB,eAAL,EAAsB4B,GAAtB,CAA0BL,GAA1B,EAA+BQ,eAA/B;;AAEA;AACA,qBAAKK,OAAL,GAAe,IAAf;AACH,aAhCD,MAgCO;AACH;AACA,oBAAIjB,QAAQ,WAAR,IAAuBA,QAAQ,QAAnC,EAA6C;AACzCvB,gEAA0CuB,IAA1C;AACA,2BAAO,KAAP;AACH;;AAED;AACA,oBAAI,CAAC,KAAKjB,sBAAL,EAA6B+B,GAA7B,CAAiCV,GAAjC,CAAL,EAA4C;AACxC,yBAAKrB,sBAAL,EAA6B0B,GAA7B,CAAiCL,GAAjC,EAAsC,EAAtC;;AAEA;AACA,yBAAKa,OAAL,GAAe,IAAf;AACH;;AAED,oBAAIC,yBAAyB;AACzB,mCAAerB,YAAYgB,MAAZ,CAAmB,KAAK5B,oBAAL,CAAnB,CADU;AAEzB,mCAAea,YAAYe,MAAZ,CAAmB,KAAK5B,oBAAL,CAAnB,CAFU;AAGzB,4BAAQe;AAHiB,iBAA7B;;AAMA;AACA,oBAAImB,qBAAqBC,KAAKC,SAAL,CAAeH,sBAAf,CAAzB;AACA,oBAAII,kBAAkB,KAAKvC,sBAAL,EAA6BiC,GAA7B,CAAiCZ,GAAjC,CAAtB;AACA,qBAAK,IAAImB,IAAI,CAAR,EAAWC,SAAhB,EAA2BA,YAAYF,gBAAgBC,GAAhB,CAAvC,GAA8D;AAC1D,wBAAIH,KAAKC,SAAL,CAAeG,SAAf,KAA6BL,kBAAjC,EAAqD;AACjD;AACA,+BAAO,KAAP;AACH;AACJ;;AAED;AACAG,gCAAgBG,IAAhB,CAAqBP,sBAArB;;AAEA;AACA,qBAAKD,OAAL,GAAe,IAAf;AACH;;AAED,mBAAO,IAAP;AACH;;AAED;;;;;;;;;;;;;;wCAwBG;AAAA,wCAXCS,SAWD;AAAA,gBAXCA,SAWD,mCAXa,IAWb;AAAA,sCATCC,OASD;AAAA,gBATCA,OASD,iCATW,IASX;AAAA,0CAPC9B,WAOD;AAAA,gBAPCA,WAOD,qCAPe,IAOf;AAAA,0CALCC,WAKD;AAAA,gBALCA,WAKD,qCALe,IAKf;AAAA,2CAHCC,YAGD;AAAA,gBAHCA,YAGD,sCAHgB,KAGhB;AAAA,mCADCC,IACD;AAAA,gBADCA,IACD,8BADQ,WACR;;AACC;AACA0B,wBAAYzB,cAAcyB,SAAd,EAAyB,WAAzB,CAAZ;AACAC,sBAAU1B,cAAc0B,OAAd,EAAuB,SAAvB,CAAV;AACA9B,0BAAcI,cAAcJ,WAAd,EAA2B,aAA3B,CAAd;AACAC,0BAAcG,cAAcH,WAAd,EAA2B,aAA3B,CAAd;;AAEA;AACA,gBAAI,CAAC4B,SAAD,IAAc,CAACC,OAAf,IAA0B,CAAC9B,WAA3B,IAA0C,CAACC,WAA/C,EAA4D,OAAO,KAAP;;AAE5D;AACA,gBAAI8B,WAAW,IAAf;;AAEA;AACA,iBAAK,IAAIC,IAAIH,SAAb,EAAwBG,EAAEC,cAAF,CAAiBH,OAAjB,CAAxB,EAAmDE,EAAElB,GAAF,CAAM,CAAN,EAAS,MAAT,CAAnD,EAAqE;AACjE;AACA;AACAiB,4BAAY,KAAKG,OAAL,CAAa;AACrBnC,0BAAMiC,CADe;AAErBhC,iCAAaA,WAFQ;AAGrBC,iCAAaA,WAHQ;AAIrBC,kCAAcA,YAJO;AAKrBC,0BAAMA;AALe,iBAAb,CAAZ;AAOH;;AAED,mBAAO4B,QAAP;AACH;;AAED;;;;;;;;;uCAQG;AAAA,mCADChC,IACD;AAAA,gBADCA,IACD,8BADQ,IACR;;AACC;AACAA,mBAAOK,cAAcL,IAAd,EAAoB,MAApB,CAAP;AACA,gBAAI,CAACA,IAAL,EAAW,OAAO,KAAP;;AAEX;AACA,gBAAIQ,MAAMC,UAAUT,IAAV,CAAV;AACA,gBAAI,CAAC,KAAKf,eAAL,EAAsBiC,GAAtB,CAA0BV,GAA1B,CAAL,EAAqC,OAAO,KAAP;;AAErC,gBAAI4B,UAAU,KAAKnD,eAAL,EAAsBmC,GAAtB,CAA0BZ,GAA1B,CAAd;AACA;AACA,gBAAI6B,eAAe;AACf,wBAAQD,QAAQpC,IADD;AAEf,+BAAeoC,QAAQnC,WAFR;AAGf,+BAAemC,QAAQlC,WAHR;AAIf,wBAAQkC,QAAQhC;AAJD,aAAnB;;AAOA;AACA,gBAAI,KAAKjB,sBAAL,EAA6B+B,GAA7B,CAAiCV,GAAjC,CAAJ,EAA2C;AACvC6B,6BAAaC,OAAb,GAAuB,KAAKnD,sBAAL,EAA6BiC,GAA7B,CAAiCZ,GAAjC,CAAvB;AACH;;AAED,mBAAO6B,YAAP;AACH;;AAED;;;;;;;;;;4CAUG;AAAA,wCAFCP,SAED;AAAA,gBAFCA,SAED,mCAFa,IAEb;AAAA,sCADCC,OACD;AAAA,gBADCA,OACD,iCADW,IACX;;AACC;AACAD,wBAAYzB,cAAcyB,SAAd,EAAyB,WAAzB,CAAZ;AACAC,sBAAU1B,cAAc0B,OAAd,EAAuB,SAAvB,CAAV;AACA,gBAAI,CAACD,SAAD,IAAc,CAACC,OAAnB,EAA4B,OAAO,EAAP;;AAE5B;AACA,gBAAIQ,cAAc,EAAlB;AACA,iBAAK,IAAIN,IAAIH,SAAb,EAAwBG,EAAEC,cAAF,CAAiBH,OAAjB,CAAxB,EAAmDE,EAAElB,GAAF,CAAM,CAAN,EAAS,MAAT,CAAnD,EAAqE;AACjE,oBAAIyB,eAAe,KAAKC,OAAL,CAAa;AAC5BzC,0BAAMiC;AADsB,iBAAb,CAAnB;AAGA,oBAAIO,YAAJ,EAAkB;AACdD,gCAAYV,IAAZ,CAAiBW,YAAjB;AACH;AACJ;;AAED,mBAAOD,WAAP;AACH;;;4BAnQa;AACV,mBAAO,KAAKjD,iBAAL,CAAP;AACH;;AAED;;;AAGA;;0BACYoD,K,EAAO;AACf,iBAAKpD,iBAAL,IAA0BoD,KAA1B;AACH;;;;;;AA4PL,SAASrC,aAAT,CAAuBsC,UAAvB,EAAmCC,OAAnC,EAA4C;AACxC;AACA,QAAI,CAAC7D,OAAO8D,QAAP,CAAgBF,UAAhB,CAAL,EAAkC;AAC9B;AACA,YAAIG,UAAU/D,OAAO4D,UAAP,EAAmB,CAC7B5D,OAAOgE,QADsB,EAE7B/D,SAASY,iBAFoB,EAG7BZ,SAASW,iBAHoB,EAI7B,YAJ6B,CAAnB,CAAd;;AAOA;AACA,YAAI,CAACmD,QAAQE,OAAR,EAAL,EAAwB;AACpBnE,0CAA4B+D,OAA5B,QAAwCD,UAAxC;AACA,mBAAO,KAAP;AACH;;AAED;AACAA,qBAAaG,OAAb;AACH;;AAED;AACA,WAAOH,UAAP;AACH;;AAED,SAASlC,SAAT,CAAmBT,IAAnB,EAAyB;AACrB;AACA;AACA;AACA,WAAOiD,KAAKC,KAAL,CAAW,CAAElD,KAAKmD,IAAL,KAAc,EAAf,GAAqBnD,KAAKoD,SAAL,EAAtB,IAA0C,IAArD,CAAP;AACH;;AAEDC,OAAOC,OAAP,GAAiB/D,QAAjB","file":"schedule.js","sourcesContent":["\"use strict\";\r\n\r\nvar Log = require(\"./debugPrint\");\r\nvar moment = require(\"moment-timezone\");\r\nvar settings = require(\"./settings\");\r\n\r\nvar s_scheduleDates = Symbol();\r\nvar s_scheduleDatesSpecial = Symbol();\r\nvar s_scheduleDateFormat = Symbol();\r\nvar s_scheduleTimeFormat = Symbol();\r\nvar s_scheduleIsDirty = Symbol();\r\n\r\n/**\r\n * @typedef ScheduleData\r\n * @type Object\r\n * @property {String} date Date this schedule data applies to (formatted by DateFormat)\r\n * @property {String} openingTime Opening time for this date (formatted by TimeFormat)\r\n * @property {String} closingTime Closing time for this date (formatted by TimeFormat)\r\n * @property {String} type Whether this schedule data refers to an \"Operating\", \"Closed\" or \"Refurbishment\" status\r\n * @property {SpecialScheduleData[]} special Won't exist if no special times exist for this date\r\n */\r\n\r\n/**\r\n * @typedef SpecialScheduleData\r\n * @type Object\r\n * @property {String} openingTime Opening time for this special schedule data (formatted by TimeFormat)\r\n * @property {String} closingTime Closing time for this special schedule data (formatted by TimeFormat)\r\n * @property {String} type Type of special schedule this is (eg. \"Extra Magic Hours\")\r\n */\r\n\r\n/**\r\n * Schedule class to hold opening and closing times for parks and rides etc.\r\n * Supports standard and \"special\" opening times\r\n * @class\r\n */\r\nclass Schedule {\r\n    /**\r\n     * Create a new Schedule object\r\n     * @param {Object} scheduleConfig\r\n     * @param {String} [scheduleConfig.dateFormat] Moment.js compatible format string to return dates as. See http://momentjs.com/docs/#/displaying/format/\r\n     * @param {String} [scheduleConfig.timeFormat] Moment.js compatible format string to return times as. See http://momentjs.com/docs/#/displaying/format/\r\n     */\r\n    constructor({\r\n        dateFormat = null,\r\n        timeFormat = null,\r\n    } = {}) {\r\n        // use Map for better structure (int -> data)\r\n        //  int is the number of days since Unix Epoch\r\n        this[s_scheduleDates] = new Map();\r\n        // also one for special hours (this is actually int -> data[] to support multiple special times)\r\n        this[s_scheduleDatesSpecial] = new Map();\r\n        // this schedule's date print format\r\n        this[s_scheduleDateFormat] = dateFormat || settings.DefaultDateFormat;\r\n        // this schedule's time print format\r\n        this[s_scheduleTimeFormat] = timeFormat || settings.DefaultTimeFormat;\r\n\r\n        // initially, our data is empty, so not really dirty (we don't want to save empty data by mistake)\r\n        this[s_scheduleIsDirty] = false;\r\n    }\r\n\r\n    /**\r\n     * Write schedule data to a JSON object\r\n     * @returns {Object} Current schedule data\r\n     */\r\n    toJSON() {\r\n        return {\r\n            dates: this[s_scheduleDates],\r\n            datesSpecial: this[s_scheduleDatesSpecial],\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Restore schedule data state from a JSON object\r\n     * @param {Object} Object from toJSON to restore data from\r\n     */\r\n    fromJSON(scheduleData) {\r\n        this[s_scheduleDates] = scheduleData.dates;\r\n        this[s_scheduleDatesSpecial] = scheduleData.datesSpecial;\r\n    }\r\n\r\n    /**\r\n     * Whether the data needs to be cached\r\n     * @type {Boolean}\r\n     */\r\n    get IsDirty() {\r\n        return this[s_scheduleIsDirty];\r\n    }\r\n\r\n    /**\r\n     * Set the data as dirty\r\n     */\r\n    // TODO - bring this as a private property and make schedules handle their own caching\r\n    set IsDirty(value) {\r\n        this[s_scheduleIsDirty] = value;\r\n    }\r\n\r\n    /**\r\n     * Set schedule data for a date\r\n     * @param {Object} scheduleData\r\n     * @param {Moment|String} [scheduleData.date=scheduleData.openingTime] Moment.js date object (or a valid date String to be parsed by Moment JS). Will use openingTime if this is not supplied\r\n     * @param {Moment|String} [scheduleData.openingTime] Moment.js date object of this day's opening time (or a valid date String to be parsed by Moment JS) (can be ignored if type is Closed)\r\n     * @param {Moment|String} [scheduleData.closingTime] Moment.js date object of this day's closing time (or a valid date String to be parsed by Moment JS) (can be ignored if type is Closed)\r\n     * @param {Boolean} [scheduleData.specialHours=false] Is this schedule data part of schedule special hours?\r\n     * @param {String} [scheduleData.type=Operating] The schedule type. Normal schedules should always be \"Operating\", \"Closed\" or \"Refurbishment\". Special schedules can be any String (eg. Extra Magic Hours).\r\n     * @returns {Boolean} success Returns true if the operation was a success and the data was actually changed\r\n     */\r\n    SetDate({\r\n        // the day to set the schedule data for\r\n        date = null,\r\n        // opening time for this day\r\n        openingTime = null,\r\n        // closing time for this day\r\n        closingTime = null,\r\n        // is this special hours data? (default: false)\r\n        specialHours = false,\r\n        // the type of this schedule date (default: Operating)\r\n        type = \"Operating\"\r\n    }) {\r\n        // if we haven't been supplied a date, use the opening time\r\n        if (!date) date = openingTime;\r\n\r\n        // check our date is a valid momentjs object\r\n        date = parseDateTime(date, \"date\");\r\n\r\n        // special case, if this is a closed date, support not passing in opening and closing times\r\n        if (type == \"Closed\") {\r\n            if (!openingTime) openingTime = date.startOf(\"day\");\r\n            if (!closingTime) closingTime = date.endOf(\"day\");\r\n        }\r\n\r\n        openingTime = parseDateTime(openingTime, \"openingTime\");\r\n        closingTime = parseDateTime(closingTime, \"closingTime\");\r\n\r\n        // if any of our dates are invalid, return false\r\n        if (!date || !openingTime || !closingTime) return false;\r\n\r\n        // calculate the days since Unix Epoch\r\n        var day = dateToDay(date);\r\n\r\n        // make sure opening and closing times are in the correct day!\r\n        var todaySet = {\r\n            \"year\": date.year(),\r\n            \"month\": date.month(),\r\n            \"date\": date.date()\r\n        };\r\n        openingTime.set(todaySet);\r\n        closingTime.set(todaySet);\r\n\r\n        // work out if the closing time is in the following day\r\n        if (closingTime.isBefore(openingTime)) {\r\n            // add 1 day if the closing time comes before the opening time (implying it's open past midnight!)\r\n            closingTime.add(1, \"day\");\r\n        }\r\n\r\n        // build schedule data object and add it to our schedule map\r\n        if (!specialHours) {\r\n            // check our schedule type is sane\r\n            if (type != \"Operating\" && type != \"Closed\" && type != \"Refurbishment\") {\r\n                Log(`Tried to use invalid schedule type ${type} for standard schedule data (must be Operating, Closed or Refurbishment)`);\r\n                return false;\r\n            }\r\n\r\n            var newScheduleData = {\r\n                \"date\": date.format(this[s_scheduleDateFormat]),\r\n                \"openingTime\": openingTime.format(this[s_scheduleTimeFormat]),\r\n                \"closingTime\": closingTime.format(this[s_scheduleTimeFormat]),\r\n                \"type\": type\r\n            };\r\n\r\n            // check if we already have this data for this day (don't invalidate cache etc if it hasn't changed)\r\n            if (this[s_scheduleDates].has(day)) {\r\n                var checkDirtyObj = this[s_scheduleDates].get(day);\r\n                if (\r\n                    checkDirtyObj.date == newScheduleData.date &&\r\n                    checkDirtyObj.openingTime == newScheduleData.openingTime &&\r\n                    checkDirtyObj.closingTime == newScheduleData.closingTime &&\r\n                    checkDirtyObj.type == newScheduleData.type) {\r\n                    // data is identical to existing object, don't update\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            // set this day's schedule data\r\n            this[s_scheduleDates].set(day, newScheduleData);\r\n\r\n            // we have new data, so mark it as dirty to get cached\r\n            this.IsDirty = true;\r\n        } else {\r\n            // special hours can't be Operating or Closed, that is for normal hours\r\n            if (type == \"Operating\" || type == \"Closed\") {\r\n                Log(`Tried to use invalid schedule type ${type} for special schedule data (can't be Operating or Closed)`);\r\n                return false;\r\n            }\r\n\r\n            // add a new special hours array if we don't already have one\r\n            if (!this[s_scheduleDatesSpecial].has(day)) {\r\n                this[s_scheduleDatesSpecial].set(day, []);\r\n\r\n                // we have new data, so mark it as dirty to get cached\r\n                this.IsDirty = true;\r\n            }\r\n\r\n            var newSpecialScheduleData = {\r\n                \"openingTime\": openingTime.format(this[s_scheduleTimeFormat]),\r\n                \"closingTime\": closingTime.format(this[s_scheduleTimeFormat]),\r\n                \"type\": type\r\n            };\r\n\r\n            // check we don't already have this special data in our array\r\n            var newDataStringified = JSON.stringify(newSpecialScheduleData);\r\n            var specialDayArray = this[s_scheduleDatesSpecial].get(day);\r\n            for (var i = 0, checkData; checkData = specialDayArray[i++];) {\r\n                if (JSON.stringify(checkData) == newDataStringified) {\r\n                    // this object already exists, so bail out\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            // add our new data to the specials array\r\n            specialDayArray.push(newSpecialScheduleData);\r\n\r\n            // we have new data, so mark it as dirty to get cached\r\n            this.IsDirty = true;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set a range of dates with the same schedule data\r\n     * @param {Object} scheduleData\r\n     * @param {Moment|String} scheduleData.startDate Moment.js date object to start schedule date range (or a valid date String to be parsed by Moment JS)\r\n     * @param {Moment|String} scheduleData.endDate Moment.js date object to end schedule date range (or a valid date String to be parsed by Moment JS)\r\n     * @param {Moment|String} scheduleData.openingTime Moment.js date object of this day's opening time (or a valid date String to be parsed by Moment JS)\r\n     * @param {Moment|String} scheduleData.closingTime Moment.js date object of this day's closing time (or a valid date String to be parsed by Moment JS)\r\n     * @param {Boolean} [scheduleData.specialHours=false] Is this schedule data part of schedule special hours?\r\n     * @param {String} [scheduleData.type=Operating] The schedule type. Normal schedules should always be \"Operating\", \"Closed\" or \"Refurbishment\". Special schedules can be any String (eg. Extra Magic Hours).\r\n     * @returns {Boolean} success \r\n     */\r\n    SetRange({\r\n        // first date of the range to set schedule for\r\n        startDate = null,\r\n        // first date of the range to set schedule for\r\n        endDate = null,\r\n        // opening time for this day\r\n        openingTime = null,\r\n        // closing time for this day\r\n        closingTime = null,\r\n        // is this special hours data? (default: false)\r\n        specialHours = false,\r\n        // the type of this schedule date (default: Operating)\r\n        type = \"Operating\"\r\n    }) {\r\n        // check our input dates are valid\r\n        startDate = parseDateTime(startDate, \"startDate\");\r\n        endDate = parseDateTime(endDate, \"endDate\");\r\n        openingTime = parseDateTime(openingTime, \"openingTime\");\r\n        closingTime = parseDateTime(closingTime, \"closingTime\");\r\n\r\n        // if any of our dates are invalid, return false\r\n        if (!startDate || !endDate || !openingTime || !closingTime) return false;\r\n\r\n        // if any of our dates result in invalid data, return false\r\n        var retValue = true;\r\n\r\n        // add each day using SetDate\r\n        for (var m = startDate; m.isSameOrBefore(endDate); m.add(1, \"days\")) {\r\n            // retValue AND= means this becomes false with any one failed result\r\n            //  if we do fail, we also just keep going to try and get as much done as possible :) \r\n            retValue &= this.SetDate({\r\n                date: m,\r\n                openingTime: openingTime,\r\n                closingTime: closingTime,\r\n                specialHours: specialHours,\r\n                type: type\r\n            });\r\n        }\r\n\r\n        return retValue;\r\n    }\r\n\r\n    /**\r\n     * Get schedule data for a specific date\r\n     * @param {Object} dateData\r\n     * @param {Moment|String} dateData.date Moment.js date object to fetch schedule data for (or a valid date String to be parsed by Moment JS)\r\n     * @return {ScheduleData} scheduleResult Can be false if no data exists for the requested date\r\n     */\r\n    GetDate({\r\n        date = null\r\n    }) {\r\n        // check our date is valid\r\n        date = parseDateTime(date, \"date\");\r\n        if (!date) return false;\r\n\r\n        // do we have this day in our schedule data?\r\n        var day = dateToDay(date);\r\n        if (!this[s_scheduleDates].has(day)) return false;\r\n\r\n        var dayData = this[s_scheduleDates].get(day);\r\n        // copy data into the return object (otherwise we end up modifying the actual date data!)\r\n        var returnObject = {\r\n            \"date\": dayData.date,\r\n            \"openingTime\": dayData.openingTime,\r\n            \"closingTime\": dayData.closingTime,\r\n            \"type\": dayData.type\r\n        };\r\n\r\n        // add special schedules if we have any!\r\n        if (this[s_scheduleDatesSpecial].has(day)) {\r\n            returnObject.special = this[s_scheduleDatesSpecial].get(day);\r\n        }\r\n\r\n        return returnObject;\r\n    }\r\n\r\n    /**\r\n     * Get schedule data for a range of dates\r\n     * @param {Object} dateData\r\n     * @param {Moment|String} dateData.startDate Moment.js date object to fetch schedule data from (or a valid date String to be parsed by Moment JS)\r\n     * @param {Moment|String} dateData.endDate Moment.js date object to fetch schedule data from (or a valid date String to be parsed by Moment JS)\r\n     * @return {ScheduleData[]} scheduleResult Can be an empty array if there is no valid data (won't be null)\r\n     */\r\n    GetDateRange({\r\n        startDate = null,\r\n        endDate = null,\r\n    }) {\r\n        // check start and end date are valid\r\n        startDate = parseDateTime(startDate, \"startDate\");\r\n        endDate = parseDateTime(endDate, \"endDate\");\r\n        if (!startDate || !endDate) return [];\r\n\r\n        // fetch each day of the range and add it to our result\r\n        var returnArray = [];\r\n        for (var m = startDate; m.isSameOrBefore(endDate); m.add(1, \"days\")) {\r\n            var dateSchedule = this.GetDate({\r\n                date: m\r\n            });\r\n            if (dateSchedule) {\r\n                returnArray.push(dateSchedule);\r\n            }\r\n        }\r\n\r\n        return returnArray;\r\n    }\r\n}\r\n\r\nfunction parseDateTime(dateObject, varName) {\r\n    // check if it's already a valid Moment object\r\n    if (!moment.isMoment(dateObject)) {\r\n        // try and parse if this is a string\r\n        var newDate = moment(dateObject, [\r\n            moment.ISO_8601,\r\n            settings.DefaultTimeFormat,\r\n            settings.DefaultDateFormat,\r\n            \"YYYY-MM-DD\",\r\n        ]);\r\n\r\n        // check if we ended up with a valid timestamp\r\n        if (!newDate.isValid()) {\r\n            Log(`Invalid scheduleData.${varName}:`, dateObject);\r\n            return false;\r\n        }\r\n\r\n        // use our successful string parse!\r\n        dateObject = newDate;\r\n    }\r\n\r\n    // we got this far, success! return the new Moment object (or the original one if it was always good!)\r\n    return dateObject;\r\n}\r\n\r\nfunction dateToDay(date) {\r\n    // calculate the day since Unix Epoch\r\n    //  .unix returns in UTC, so we convert to minutes and add on the utcOffset (then convert from minutes to days)\r\n    //  finally we Math.floor to round downwards to get the current day as an integer\r\n    return Math.floor(((date.unix() / 60) + date.utcOffset()) / 1440);\r\n}\r\n\r\nmodule.exports = Schedule;"]}