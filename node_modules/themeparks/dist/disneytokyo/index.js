"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var random_useragent = require("random-useragent");

var Moment = require("moment-timezone");

var Park = require("../park");

var s_apiKey = Symbol();
var s_apiAuth = Symbol();
var s_apiOS = Symbol();
var s_apiVersion = Symbol();
var s_apiBase = Symbol();
var s_webUserAgent = Symbol();
var s_parkID = Symbol();
var s_deviceID = Symbol();

/**
 * Implements the Tokyo Disneyland API framework.
 * @class
 * @extends Park
 */

var DisneyTokyoPark = function (_Park) {
    _inherits(DisneyTokyoPark, _Park);

    /**
     * Create new DisneyTokyoPark Object.
     * This object should not be called directly, but rather extended for each of the individual Tokyo Disneyland parks
     * @param {Object} options
     * @param {String} options.park_id Tokyo Disneyland API park ID
     */
    function DisneyTokyoPark() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, DisneyTokyoPark);

        options.name = options.name || "Tokyo Disneyland Park";
        options.timezone = options.timezone || "Asia/Tokyo";

        options.useragent = options.useragent || "TokyoDisneyResortApp/1.0.8 Android/8.1.0";

        // inherit from base class

        var _this = _possibleConstructorReturn(this, (DisneyTokyoPark.__proto__ || Object.getPrototypeOf(DisneyTokyoPark)).call(this, options));

        _this[s_apiKey] = options.api_key || "818982cd6a62e7927700a4fbabcd4534a4657a422711a83c725433839b172371";
        _this[s_apiAuth] = options.api_auth || "MmYyZDYzehoVwD52FWYyDvo22aGvetu6uaGGKdN6FILO9lp2XS17DF//BA+Gake8oJ0GKlGnJDWu/boVa32d7PfCeTqCJA==";
        _this[s_apiOS] = options.api_os || "Android 8.1.0";
        _this[s_apiVersion] = options.api_version || "1.0.11";
        _this[s_apiBase] = options.api_base || "https://api-portal.tokyodisneyresort.jp";

        if (options.park_id === undefined) throw new Error("No Park ID passed to DisneyTokyoPark object constructor");
        _this[s_parkID] = options.park_id;

        _this[s_webUserAgent] = random_useragent.getRandom(function (ua) {
            return ua.osName == "Android";
        });
        return _this;
    }

    // override Fastpass Getter to declare support for Fastpass


    _createClass(DisneyTokyoPark, [{
        key: "GetAPIHeaders",


        /**
         * Refresh/Fetch new Wait Times for this Tokyo Disney Resort park
         * @returns {Promise}
         */
        value: function GetAPIHeaders() {
            var headers = {
                "x-api-key": this[s_apiKey],
                "X-PORTAL-LANGUAGE": "ja",
                "X-PORTAL-OS-VERSION": this[s_apiOS],
                "X-PORTAL-APP-VERSION": this[s_apiVersion],
                "X-PORTAL-AUTH": this[s_apiAuth],
                "X-PORTAL-DEVICE-NAME": "shamu",
                connection: "keep-alive",
                "Accept-Encoding": "gzip",
                "Accept": "application/json",
                "Content-Type": "application/json"
            };

            if (this[s_deviceID]) {
                headers["X-PORTAL-DEVICE-ID"] = this[s_deviceID];
            }

            return headers;
        }
    }, {
        key: "CheckLatest",
        value: function CheckLatest() {
            var _this2 = this;

            var Depth = 3;

            var OriginalVersion = this[s_apiVersion];

            var TestVersion = function TestVersion() {
                if (Depth <= 0) {
                    return Promise.reject(new Error("TDR API is out-of-date (failed to use version " + OriginalVersion + "). Please update the library."));
                }

                return _this2.HTTP({
                    url: _this2[s_apiBase] + "/rest/v1/applications/versions",
                    method: "GET",
                    headers: _this2.GetAPIHeaders()
                }).then(function (resp) {
                    if (!resp || !resp.latest) {
                        _this2[s_apiVersion] = _this2[s_apiVersion].split(".").map(function (x, idx) {
                            return idx == 2 ? "" + (Number(x) + 1) : x;
                        }).join(".");
                        _this2.Log("Bumping version from " + OriginalVersion + " to " + _this2[s_apiVersion]);
                        Depth--;

                        return TestVersion();
                    }

                    return Promise.resolve();
                });
            };

            return TestVersion();
        }
    }, {
        key: "FetchDeviceID",
        value: function FetchDeviceID() {
            var _this3 = this;

            if (this[s_deviceID]) return Promise.resolve(this[s_deviceID]);

            return this.Cache.Wrap("tdrDeviceID", function () {
                return _this3.HTTP({
                    url: _this3[s_apiBase] + "/rest/v1/devices",
                    method: "POST",
                    headers: _this3.GetAPIHeaders()
                }).then(function (data) {
                    if (data && data.deviceId) {
                        _this3.Log("Fetched device ID for TDR: " + data.deviceId);

                        _this3[s_deviceID] = data.deviceId;

                        return _this3.CheckLatest().then(function () {
                            return Promise.resolve(data.deviceId);
                        });
                    }

                    return Promise.reject(new Error("Unable to fetch device ID: " + data));
                });
            }, 60 * 60 * 24 * 90);
        }
    }, {
        key: "FetchWaitTimes",
        value: function FetchWaitTimes() {
            var _this4 = this;

            // first get our ride names etc.
            return this.FetchRideData().then(function (rides) {
                return _this4.FetchWaitTimesJSON().then(function (data) {
                    for (var i = 0; i < data.attractions.length; i++) {
                        var ride = data.attractions[i];
                        // skip any rides we don't recognise
                        if (!rides[ride.id]) continue;
                        // skip rides with no wait time service
                        if (ride.standbyTimeDisplayType == "FIXED") continue;
                        // skip anything not type 1 or 2 (rides and shows)
                        if (rides[ride.id].type >= 3) continue;

                        var rideObject = _this4.GetRideObject({
                            id: ride.id,
                            name: rides[ride.id].name
                        });

                        rideObject.FastPass = rides[ride.id].fastpass;

                        if (ride.operatingStatus == "CLOSE_NOTICE") {
                            // ride is temporarily closed
                            rideObject.WaitTime = -2;
                        } else if (ride.facilityStatus == "CANCEL") {
                            // ride is closed for the day
                            rideObject.WaitTime = -1;
                        } else if (ride.operatingStatus == "OPEN") {
                            rideObject.WaitTime = ride.standbyTime !== undefined && ride.standbyTime >= 0 ? ride.standbyTime : 0;
                        } else {
                            rideObject.WaitTime = -1;
                        }
                    }

                    return Promise.resolve();
                });
            });
        }
    }, {
        key: "FetchWaitTimesJSON",
        value: function FetchWaitTimesJSON() {
            var _this5 = this;

            return this.FetchDeviceID().then(function () {
                return _this5.HTTP({
                    url: _this5[s_apiBase] + "/rest/v1/facilities/conditions",
                    method: "GET",
                    headers: _this5.GetAPIHeaders()
                });
            });
        }
    }, {
        key: "FetchRideData",
        value: function FetchRideData() {
            var _this6 = this;

            return this.Cache.Wrap("ridedata", function () {
                // first get our English ride names
                return _this6.GetEnglishNames().then(function (englishNames) {
                    return _this6.FetchDeviceID().then(function () {
                        // fetch ride data from App API
                        return _this6.HTTP({
                            url: _this6[s_apiBase] + "/rest/v1/facilities",
                            method: "GET",
                            headers: _this6.GetAPIHeaders()
                        }).then(function (body) {
                            if (!body) {
                                return Promise.reject("Failed to find entries in ride data response");
                            }

                            var rideData = {};

                            for (var i = 0; i < body.attractions.length; i++) {
                                var attr = body.attractions[i];

                                // skip attractions from the other park
                                if (attr.parkType.toLowerCase() != _this6[s_parkID]) continue;

                                var englishData = englishNames[Number(attr.facilityCode)];

                                rideData[attr.id] = {
                                    name: englishData && englishData.name !== undefined ? englishData.name : attr.nameKana,
                                    fastpass: !!attr.fastpass,
                                    type: attr.attractionType.id,
                                    facilityCode: Number(attr.facilityCode)
                                };
                            }

                            return Promise.resolve(rideData);
                        });
                    });
                });
            }, 86400);
        }
    }, {
        key: "GetEnglishNames",
        value: function GetEnglishNames() {
            var _this7 = this;

            return this.Cache.Wrap("ridenames", function () {
                // fetch ride names
                return _this7.HTTP({
                    url: "https://www.tokyodisneyresort.jp/en/" + _this7[s_parkID] + "/attraction.html",
                    headers: {
                        "Referer": "https://www.tokyodisneyresort.jp/en/" + _this7[s_parkID] + "/attraction.html",
                        connection: "keep-alive",
                        "User-Agent": _this7[s_webUserAgent]
                    },
                    retryDelay: 1000 * 10
                }).then(function (body) {
                    if (!body) {
                        return Promise.reject("Failed to find entries in English ride names data response");
                    }

                    var regexGetRideNames = /e">([^<]+)<\/p>[\s\n]*<a href="\/en\/td[sl]\/attraction\/detail\/([0-9]+)\/">[\s\n]*<div class="headingArea">[\s\n]*<div class="headingAreaInner">[\s\n]*<h3 class="heading3">([^<]+)<\/h3>/g;

                    var match = void 0;
                    var rideData = {};
                    while (match = regexGetRideNames.exec(body)) {
                        rideData[Number(match[2])] = {
                            name: match[3],
                            area: match[1]
                        };
                    }

                    // add area name to any duplicate names
                    for (var id in rideData) {
                        var matches = [];
                        for (var compId in rideData) {
                            if (rideData[id].name == rideData[compId].name) {
                                matches.push(compId);
                            }
                        }

                        if (matches.length > 1) {
                            for (var i = 0; i < matches.length; i++) {
                                rideData[matches[i]].name = rideData[matches[i]].area + " " + rideData[matches[i]].name;
                            }
                        }
                    }

                    // missing facility 245 from scrape?
                    if (rideData[244] && !rideData[245]) rideData[245] = rideData[244];

                    return Promise.resolve(rideData);
                });
            }, 86400);
        }
    }, {
        key: "FetchCalendarJSON",
        value: function FetchCalendarJSON() {
            var _this8 = this;

            var today = Moment().tz(this.Timezone).format("YYYY-MM-DD");
            return this.FetchDeviceID().then(function () {
                return _this8.HTTP({
                    url: _this8[s_apiBase] + "/rest/v1/parks/calendars?since=" + today,
                    method: "GET",
                    headers: _this8.GetAPIHeaders()
                });
            });
        }
    }, {
        key: "FetchOpeningTimes",
        value: function FetchOpeningTimes() {
            var _this9 = this;

            return this.FetchCalendarJSON().then(function (data) {
                for (var i = 0, day; day = data[i++];) {
                    // skip times for the wrong park
                    if (day.parkType.toLowerCase() != _this9[s_parkID]) continue;

                    _this9.Schedule.SetDate({
                        date: Moment.tz(day.date, "YYYY-MM-DD", _this9.Timezone),
                        openingTime: Moment.tz(day.date + " " + day.openTime, "YYYY-MM-DD HH:mm", _this9.Timezone),
                        closingTime: Moment.tz(day.date + " " + day.closeTime, "YYYY-MM-DD HH:mm", _this9.Timezone),
                        type: day.closedDay ? "Closed" : "Operating"
                    });
                }
            });
        }
    }, {
        key: "FastPass",
        get: function get() {
            return true;
        }
    }]);

    return DisneyTokyoPark;
}(Park);

module.exports = DisneyTokyoPark;
//# sourceMappingURL=index.js.map