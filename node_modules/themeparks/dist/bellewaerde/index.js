"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// include core Park class
var Park = require("../park");

var Moment = require("moment-timezone");

var rawRideData = require("./bellewaerdeData.js");
var rideData = {};
for (var i = 0, ride; ride = rawRideData[i++];) {
    rideData[ride.code] = ride;
}

var s_apiBase = Symbol();
var s_calendarURL = Symbol();

/**
 * Implements the Bellewaerde Park API
 * @class
 * @extends Park
 */

var Bellewaerde = function (_Park) {
    _inherits(Bellewaerde, _Park);

    function Bellewaerde() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, Bellewaerde);

        options.name = options.name || "Bellewaerde";
        options.timezone = options.timezone || "Europe/Brussels";
        options.latitude = options.latitude || 50.846996;
        options.longitude = options.longitude || 2.947948;

        // inherit from base class

        // API Options
        var _this = _possibleConstructorReturn(this, (Bellewaerde.__proto__ || Object.getPrototypeOf(Bellewaerde)).call(this, options));

        _this[s_apiBase] = options.api_base || "http://bellewaer.de/realtime/api/";
        _this[s_calendarURL] = options.calendarURL || "https://www.bellewaerde.be/en/api/calendar/";
        return _this;
    }

    _createClass(Bellewaerde, [{
        key: "FetchWaitTimes",
        value: function FetchWaitTimes() {
            return new Promise(function (resolve, reject) {
                this.HTTP({
                    url: this[s_apiBase] + "api-realtime.php"
                }).then(function (waittimes) {
                    // loop over returned data
                    var rideNames = {};

                    for (var i = 0, ridetime; ridetime = waittimes[i++];) {
                        // Filter attractions from poi
                        if (rideData[ridetime.id] && rideData[ridetime.id].type === "Attractions") {
                            var rideObject = this.GetRideObject({
                                id: ridetime.id,
                                name: rideData[ridetime.id].name
                            });

                            rideObject.WaitTime = Number(ridetime.wait) || 0;
                        }
                    }

                    resolve(rideNames);
                }.bind(this), reject);
            }.bind(this));
        }

        /**
         * Request park opening times.
         * @returns {Promise}
         */

    }, {
        key: "FetchOpeningTimes",
        value: function FetchOpeningTimes() {
            var _this2 = this;

            // calculate how many (and which) years we want to check
            var endYear = Moment().tz(this.Timezone).add(this.ScheduleDays, "days");
            var datePointer = Moment().tz(this.Timezone);
            var years = [];

            this.Log("Fetching opening hours between " + datePointer.format() + " and " + endYear.format());

            // slide along between start and end until we go past endYear to get an array of required year combos
            while (datePointer.isSameOrBefore(endYear, "year")) {
                years.push(datePointer.format("YYYY"));
                datePointer.add(1, "year");
            }

            // loop through each year, calling FetchYearOpeningTimes
            return Promise.all(years.map(function (year) {
                return _this2.FetchYearOpeningTimes(year);
            })).then(function (results) {
                // inject results into calendar
                results.map(function (hours) {
                    hours.map(function (times) {
                        _this2.Schedule.SetDate(times);
                    });
                });

                return results;
            });
        }

        /**
         * Fetch park opening times for a specific year and add to park's opening times
         * @param {String} [year]
         */

    }, {
        key: "FetchYearOpeningTimes",
        value: function FetchYearOpeningTimes(year) {
            var _this3 = this;

            return this.HTTP({
                url: this[s_calendarURL] + year,
                method: "GET",
                data: {
                    _format: "json"
                },
                json: true
            }).then(function (openingJSON) {
                if (openingJSON === null) {
                    return Promise.reject("API didn't return expected format");
                }

                var result = [];
                Object.keys(openingJSON.opening_hours).forEach(function (key) {
                    //FYI, status: "open" / "closed" / "soldout"
                    if (openingJSON.opening_hours[key].status === "open") {
                        result.push({
                            date: Moment.tz(key + "/" + year, "MM/DD/YYYY", _this3.Timezone),
                            openingTime: Moment.tz(key + "/" + year + openingJSON.opening_hours[key].mo_time, "MM/DD/YYYYHH:mm", _this3.Timezone),
                            closingTime: Moment.tz(key + "/" + year + openingJSON.opening_hours[key].mc_time, "MM/DD/YYYYHH:mm", _this3.Timezone),
                            type: "Operating"
                        });
                    } else {
                        result.push({
                            date: Moment.tz(key + "/" + year, "MM/DD/YYYY", _this3.Timezone),
                            type: "Closed"
                        });
                    }
                });

                Promise.resolve(result);
            });
        }
    }]);

    return Bellewaerde;
}(Park);

// export the class


module.exports = Bellewaerde;
//# sourceMappingURL=index.js.map