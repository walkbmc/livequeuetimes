"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Park = require("../park");
var Moment = require("moment-timezone");

var s_parkID = Symbol();
var s_authToken = Symbol();
var s_apiBase = Symbol();
var s_rideTypes = Symbol();

// this used to be "SeaWorld Park" base, but now it seems SeaWorld have dropped TE2, so refactor this for their other clients.

/**
 * Implements the The Experience Engine API framework.
 * @class
 * @extends Park
 */

var TE2Park = function (_Park) {
    _inherits(TE2Park, _Park);

    /**
     * Create new TE2Park Object.
     * This object should not be called directly, but rather extended for each of the individual TE2 parks
     * @param {Object} options
     * @param {String} options.park_id ID of the park to access the API for
     * @param {String} [options.auth_token] Auth token to use to connect to the API
     * @param {String} [options.api_base] Base URL to access the API
     * @param {String[]} [options.ride_types] Array of types that denote rides at the park (to avoid listing restaurants/toilets etc. as rides)
     */
    function TE2Park() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, TE2Park);

        options.name = options.name || "TE2 Park";

        // inherit from base class

        // assign park configurations
        var _this = _possibleConstructorReturn(this, (TE2Park.__proto__ || Object.getPrototypeOf(TE2Park)).call(this, options));

        if (!options.park_id) throw new Error("Missing park's API ID");
        _this[s_parkID] = options.park_id;

        // accept API options to override defaults if needed
        _this[s_authToken] = options.auth_token || "";
        if (_this[s_authToken] === "") {
            // eslint-disable-next-line no-console
            console.error("Please supply an 'auth_token' as a Base64 encoded username:password string for '" + options.name + "'. API credentials have been removed from this library at the request of the park technology operators.");
        }
        _this[s_apiBase] = options.api_base || "https://seas.te2.biz/v1/rest/";

        // array of valid ride types. Some implementations of the API use various types to declare rides (eg. Family/Kid/Thrill etc.)
        _this[s_rideTypes] = options.ride_types || ["Ride", "Coasters", "Family", "ThrillRides", "Kids"];
        return _this;
    }

    _createClass(TE2Park, [{
        key: "FetchWaitTimes",
        value: function FetchWaitTimes() {
            return new Promise(function (resolve, reject) {
                // first make sure we have our ride names
                this.GetRideNames().then(function (rideNames) {
                    this.GetAPIUrl({
                        url: this[s_apiBase] + "venue/" + this[s_parkID] + "/poi/all/status"
                    }).then(function (waitTimeData) {
                        for (var i = 0, ride; ride = waitTimeData[i++];) {
                            // find/create this ride object (only if we have a name for it)
                            if (rideNames[ride.id]) {
                                var rideObject = this.GetRideObject({
                                    id: ride.id,
                                    name: rideNames[ride.id]
                                });

                                if (rideObject && ride.status) {
                                    // update ride wait time
                                    rideObject.WaitTime = ride.status.waitTime ? ride.status.waitTime : ride.status.isOpen ? 0 : -1;
                                }
                            }
                        }

                        resolve();
                    }.bind(this), reject);
                }.bind(this), reject);
            }.bind(this));
        }
    }, {
        key: "FetchOpeningTimes",
        value: function FetchOpeningTimes() {
            return new Promise(function (resolve, reject) {
                this.GetAPIUrl({
                    url: this[s_apiBase] + "venue/" + this[s_parkID] + "/hours/" + Moment().tz(this.Timezone).format("YYYY-MM-DD"),
                    data: {
                        days: 30
                    }
                }).then(function (scheduleData) {
                    for (var i = 0, day; day = scheduleData[i++];) {
                        var thisDay = Moment(day.date, "YYYY-MM-DD");
                        this.Schedule.SetDate({
                            date: thisDay,
                            openingTime: day.open ? Moment(day.open, "YYYY-MM-DDTHH:mm:ss.SSSZZ").tz(this.Timezone) : thisDay,
                            closingTime: day.close ? Moment(day.close, "YYYY-MM-DDTHH:mm:ss.SSSZZ").tz(this.Timezone) : thisDay,
                            type: day.isOpen ? "Operating" : "Closed"
                        });
                    }

                    resolve();
                }.bind(this), reject);
            }.bind(this));
        }

        /**
         * Get cached (or fresh fetch) of ride names
         * @returns {Promise<Object>} Object of RideID => Ride name in English
         */

    }, {
        key: "GetRideNames",
        value: function GetRideNames() {
            return new Promise(function (resolve, reject) {
                // wrap cache request (cache ride names for 24 hours)
                this.Cache.Wrap("ridenames", this.FetchRideNames.bind(this), 60 * 60 * 24).then(resolve, reject);
            }.bind(this));
        }

        /**
         * Fetch all the rides and ride names for this park from the API (skip the cache)
         * @returns {Promise<Object>} Object of RideID => Ride name in English
         */

    }, {
        key: "FetchRideNames",
        value: function FetchRideNames() {
            return new Promise(function (resolve, reject) {
                this.Log("Fetching ride names for " + this.Name);

                // fetch POI (points-of-interest) data from API
                this.GetAPIUrl({
                    url: this[s_apiBase] + "venue/" + this[s_parkID] + "/poi/all"
                }).then(function (rideData) {
                    if (!rideData) return reject("No POI data returned from Seaworld API");

                    var rideNames = {};
                    for (var i = 0, poi; poi = rideData[i++];) {
                        // only include POI data for rides
                        if (this[s_rideTypes].indexOf(poi.type) >= 0) {
                            // grab "label", which is the English title for each POI
                            rideNames[poi.id] = poi.label;
                        }
                    }

                    resolve(rideNames);
                }.bind(this), reject);
            }.bind(this));
        }
    }, {
        key: "GetAPIUrl",
        value: function GetAPIUrl(requestObject) {
            if (this[s_authToken] === "") {
                return Promise.reject(new Error("Unable to complete request without park auth_token. auth_token has been removed from the themeparks library under request by the theme park's technology operation representatives."));
            }

            return new Promise(function (resolve, reject) {
                // make sure headers exist if they weren't set already
                if (!requestObject.headers) requestObject.headers = [];
                requestObject.headers.Authorization = "Basic " + this[s_authToken];

                // make sure we get JSON back
                requestObject.forceJSON = true;

                // send network request
                this.HTTP(requestObject).then(resolve, reject);
            }.bind(this));
        }

        /**
         * Get the park ID used by the SeaWorld/Cedar Fair API
         * @type {String}
         * */

    }, {
        key: "ParkID",
        get: function get() {
            return this[s_parkID];
        }

        /**
         * Get this park's API Base URL
         * @type {String}
         * */

    }, {
        key: "APIBase",
        get: function get() {
            return this[s_apiBase];
        }
    }]);

    return TE2Park;
}(Park);

module.exports = TE2Park;
//# sourceMappingURL=index.js.map