{"version":3,"sources":["../../lib/efteling/index.js"],"names":["Moment","require","Park","GeoLocation","s_apiVersion","Symbol","s_apiKey","s_searchURL","s_waitTimesURL","Efteling","options","name","timezone","latitude","longitude","useragent","api_version","api_key","search_url","wait_times_url","Cache","Wrap","FetchPOIData","bind","HTTP","url","data","then","result","hits","hit","Error","poiData","map","fields","category","id","latlon","match","exec","location","GetPOIData","FetchWaitTimesData","waitData","AttractionInfo","item","Type","Id","rideObject","GetRideObject","State","WaitTime","parseInt","WaitingTime","Promise","resolve","MakeRequest","language","requestOptions","error","headers","endMonth","tz","Timezone","add","ScheduleDays","datePointer","months","Log","format","isSameOrBefore","push","month","year","all","FetchOpeningTimesByMonth","results","hours","times","Schedule","SetDate","date","open","openingTime","closingTime","close","OpeningHours","i","Date","Open","Close","module","exports"],"mappings":"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","file":"index.js","sourcesContent":["const Moment = require(\"moment-timezone\");\r\n\r\nconst Park = require(\"../park\");\r\n\r\nconst GeoLocation = require(\"../geoLocation.js\");\r\n\r\nconst s_apiVersion = Symbol();\r\nconst s_apiKey = Symbol();\r\nconst s_searchURL = Symbol();\r\nconst s_waitTimesURL = Symbol();\r\n\r\n/**\r\n * Implements the Efteling API framework.\r\n * @class\r\n * @extends Park\r\n */\r\nclass Efteling extends Park {\r\n    /**\r\n     * Create new Efteling Object.\r\n     * @param {Object} [options]\r\n     * @param {String} [options.api_version] Version of the API to reference in request headers\r\n     * @param {String} [options.api_key] API Key\r\n     * @param {String} [options.digest_key] Key used to generate URL header digest\r\n     * @param {String} [options.crypto_key] Key to decrypt wait times\r\n     * @param {String} [options.crypto_cipher] Cipher to decrypt wait times\r\n     * @param {Buffer} [options.crypto_iv] IV to decrypt wait times\r\n     * @param {String} [options.search_url] URL used for fetching POI data\r\n     */\r\n    constructor(options = {}) {\r\n        options.name = options.name || \"Efteling\";\r\n\r\n        options.timezone = options.timezone || \"Europe/Amsterdam\";\r\n\r\n        // set park's location as it's entrance\r\n        options.latitude = options.latitude || 51.64990915659694;\r\n        options.longitude = options.longitude || 5.043561458587647;\r\n\r\n        options.useragent = options.useragent || \"okhttp/3.10.0\";\r\n\r\n        // inherit from base class\r\n        super(options);\r\n\r\n        // api settings\r\n        this[s_apiVersion] = options.api_version || \"5\";\r\n        this[s_apiKey] = options.api_key || \"RMHA53uMzT3ZQhrqoxujG6aVPPYwozMz5Gsb21I9\";\r\n\r\n        // URL settings\r\n        this[s_searchURL] = options.search_url || \"http://prd-search-acs.efteling.com/2013-01-01/\";\r\n        this[s_waitTimesURL] = options.wait_times_url || \"https://api.efteling.com/app/wis/\";\r\n    }\r\n\r\n    /**\r\n     * Get POI data for this park (from the cache or fetch fresh data if none is cached)\r\n     * @returns {Promise}\r\n     */\r\n    GetPOIData() {\r\n        return this.Cache.Wrap(\"poidata\", this.FetchPOIData.bind(this), 60 * 60 * 24);\r\n    }\r\n\r\n    /**\r\n     * Fetch POI data for the park.\r\n     * Don't call this function directly unless you know what you're doing. Use GetPOIData instead to use cached data when possible.\r\n     * @returns {Promise} Object of Ride IDs => Object containing name and location (GeoLocation object, if location is available for this ride)\r\n     */\r\n    FetchPOIData() {\r\n        return this.HTTP({\r\n            url: `${this[s_searchURL]}search`,\r\n            data: {\r\n                \"size\": 1000,\r\n                \"q.parser\": \"structured\",\r\n                \"q\": \"(phrase field=language 'en')\"\r\n            }\r\n        }).then((result) => {\r\n            if (!result || !result.hits || !result.hits.hit) {\r\n                throw new Error(`No results returned for POI data for Efteling Park: ${result}`);\r\n            }\r\n\r\n            var poiData = {};\r\n\r\n            result.hits.hit.map((hit) => {\r\n                if (hit.fields) {\r\n                    // ignore non-attractions\r\n                    if (hit.fields.category == \"attraction\") {\r\n                        poiData[hit.fields.id] = {\r\n                            name: hit.fields.name,\r\n                        };\r\n\r\n                        // try to parse lat/long\r\n                        //  edge-case: some rides have dud \"0.0,0.0\" location, ignore these\r\n                        if (hit.fields.latlon && hit.fields.latlon != \"0.0,0.0\") {\r\n                            var match = /([0-9.]+),([0-9.]+)/.exec(hit.fields.latlon);\r\n                            if (match) {\r\n                                poiData[hit.fields.id].location = new GeoLocation({\r\n                                    latitude: match[1],\r\n                                    longitude: match[2]\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n            return poiData;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch park wait times\r\n     * @returns {Promise}\r\n     */\r\n    FetchWaitTimes() {\r\n        // first, get POI data\r\n        return this.GetPOIData().then((poiData) => {\r\n            // then, get latest wait time results\r\n            return this.FetchWaitTimesData().then((waitData) => {\r\n                // parse and inject into park data\r\n                if (!waitData.AttractionInfo) throw new Error(\"No AttractionInfo found for Efteling Park response\");\r\n\r\n                waitData.AttractionInfo.map((item) => {\r\n                    // check we have POI data and item is an attraction\r\n                    if (item.Type == \"Attraction\" && poiData[item.Id]) {\r\n                        var rideObject = this.GetRideObject({\r\n                            id: item.Id,\r\n                            name: poiData[item.Id].name\r\n                        });\r\n\r\n                        if (rideObject) {\r\n                            // update ride with wait time data\r\n                            if(item.State == \"storing\"){\r\n                                //Ride down because of an interruption\r\n                                rideObject.WaitTime = -2;\r\n                            }else if(item.State == \"inonderhoud\"){\r\n                                //Ride down because of maintenance/refurbishment\r\n                                rideObject.WaitTime = -3; \r\n                            }else if(item.State == \"open\"){\r\n                                //Ride operating\r\n                                rideObject.WaitTime = parseInt(item.WaitingTime, 10);\r\n                            }else{\r\n                                //Ride closed\r\n                                rideObject.WaitTime = -1;\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n\r\n                return Promise.resolve();\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch the raw wait times data for Efteling Park\r\n     */\r\n    FetchWaitTimesData() {\r\n        return this.MakeRequest({\r\n            url: this[s_waitTimesURL],\r\n            data: {\r\n                language: \"en\"\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Make an API request against the Efteling API\r\n     * Injects required headers and passes request through to standard HTTP method\r\n     * See HTTP for full documentation on how to use\r\n     * @param {Object} requestOptions \r\n     * @return {Promise}\r\n     */\r\n    MakeRequest(requestOptions) {\r\n        if (!requestOptions.url) {\r\n            return Promise.error(\"No URL supplied\");\r\n        }\r\n\r\n        // add our required headers\r\n        if (!requestOptions.headers) requestOptions.headers = {};\r\n        requestOptions.headers[\"x-api-version\"] = this[s_apiVersion];\r\n        requestOptions.headers[\"x-api-key\"] = this[s_apiKey];\r\n\r\n        return this.HTTP(requestOptions);\r\n    }\r\n\r\n    /**\r\n     * Request park opening times.\r\n     * @returns {Promise}\r\n     */\r\n    FetchOpeningTimes() {\r\n        // calculate how many (and which) months we want to check\r\n        const endMonth = Moment().tz(this.Timezone).add(this.ScheduleDays, \"days\");\r\n        var datePointer = Moment().tz(this.Timezone);\r\n        const months = [];\r\n\r\n        this.Log(`Fetching opening hours between ${datePointer.format()} and ${endMonth.format()}`);\r\n\r\n        // slide along between start and end until we go past endMonth to get an array of required month/year combos\r\n        while (datePointer.isSameOrBefore(endMonth, \"month\")) {\r\n            months.push({\r\n                month: datePointer.format(\"M\"),\r\n                year: datePointer.format(\"YYYY\")\r\n            });\r\n            datePointer.add(1, \"months\");\r\n        }\r\n\r\n        // loop through each month, calling FetchOpeningTimesByMonth\r\n        return Promise.all(months.map((month) => {\r\n            return this.FetchOpeningTimesByMonth(month.month, month.year);\r\n        })).then((results) => {\r\n            // inject results into calendar\r\n            results.map((hours) => {\r\n                hours.map((times) => {\r\n                    this.Schedule.SetDate({\r\n                        date: times.open,\r\n                        openingTime: times.open,\r\n                        closingTime: times.close\r\n                    });\r\n                });\r\n            });\r\n            return results;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch park opening times for a specific month and add to park's opening times\r\n     * @param {String} month\r\n     * @param {String} [year]\r\n     * @returns {Promise} Array of Objects containing \"open\" and \"close\" Moment objects\r\n     */\r\n    FetchOpeningTimesByMonth(month, year) {\r\n        // default to current year if none supplied\r\n        if (!year) {\r\n            year = Moment.tz(this.Timezone).format(\"YYYY\");\r\n        }\r\n\r\n        return this.HTTP({\r\n            url: `https://www.efteling.com/service/cached/getpoiinfo/en/${year}/${month}`,\r\n            headers: {\r\n                \"X-Requested-With\": \"XMLHttpRequest\"\r\n            }\r\n        }).then((data) => {\r\n            if (!data) throw new Error(`Invalid data returned for park opening hours for ${month}/${year}`);\r\n            if (!data.OpeningHours) throw new Error(`No park opening hours data returned for ${month}/${year}`);\r\n\r\n            // build array of Moment objects for each open and close time\r\n            const result = [];\r\n            for (var i = 0, date; date = data.OpeningHours[i++];) {\r\n                const open = Moment.tz(`${date.Date}${date.Open}`, \"YYYY-MM-DDHH:mm\", this.Timezone);\r\n                const close = Moment.tz(`${date.Date}${date.Close}`, \"YYYY-MM-DDHH:mm\", this.Timezone);\r\n                result.push({\r\n                    open,\r\n                    close,\r\n                });\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n}\r\n\r\nmodule.exports = Efteling;\r\n"]}