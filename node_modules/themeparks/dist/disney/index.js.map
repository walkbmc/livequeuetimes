{"version":3,"sources":["../../lib/disney/index.js"],"names":["Park","require","GeoLocation","Schedule","Moment","random_useragent","Promise","s_disneyAPIResortID","Symbol","s_disneyAPIParkID","s_disneyAPIParkRegion","s_rideSchedules","s_scheduleFilters","s_rideTypes","api_accessTokenURL","api_accessTokenURLBody","api_accessTokenURLMethod","api_appID","api_baseURL","api_userAgent","getRandom","ua","osName","WaltDisneyWorldPark","options","name","timezone","latitude","longitude","useragent","resort_id","Error","park_id","park_region","ride_types","concat","schedule_filters","push","expiresIn","Cache","Wrap","resolve","reject","HTTP","url","AuthURL","method","body","AuthString","forceJSON","then","access_token","Log","expires_in","ttlExpiresIn","parseInt","Math","ceil","bind","requestObject","GetAccessToken","headers","Authorization","Accept","Date","now","GetOpeningTimes","GetAPIUrl","FetchWaitTimesURL","data","region","waitTimeData","entries","GetFacilitiesData","facilitiesData","i","ride","indexOf","type","rideId","CleanRideID","id","rideObject","GetRideObject","rideStatus","waitTime","status","toLowerCase","WaitTime","postedWaitMinutes","FastPass","fastPass","fastpass","available","FastPassReturnTimeAvailable","startTime","endTime","FastPassReturnTimeStart","tz","Timezone","FastPassReturnTimeEnd","endFillDate","add","m","isBefore","rideScheduleData","GetDate","date","SetDate","rangeStart","format","rangeEnd","FetchScheduleTimesURL","join","scheduleData","activities","schedule","scheduleID","j","scheduleTime","schedules","newScheduleData","timeZone","openingTime","closingTime","specialHours","WDWParkID","WrapGlobal","WDWResortID","FetchFacilitiesURL","element","added","coordinates","locationIDX","location","relatedLocations","coordinateIDX","coordinate","locationName","trim","geoLoc","locations","fastPassPlus","APIBase","regexTidyID","ride_id","capture","exec","length","module","exports"],"mappings":"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","file":"index.js","sourcesContent":["\"use strict\";\r\n\r\n// base Disney World park objects\r\nvar Park = require(\"../park.js\");\r\n\r\n// we're storing ride locations now, so include our location lib\r\nvar GeoLocation = require(\"../geoLocation.js\");\r\n\r\n// need schedule lib to store ride times\r\nvar Schedule = require(\"../schedule\");\r\n\r\n// Moment date/time library\r\nvar Moment = require(\"moment-timezone\");\r\n\r\n// random useragent generator\r\nvar random_useragent = require(\"random-useragent\");\r\n\r\n// include our Promise library\r\nvar Promise = require(\"../promise\");\r\n\r\n// Disney API configuration keys\r\nvar s_disneyAPIResortID = Symbol();\r\nvar s_disneyAPIParkID = Symbol();\r\nvar s_disneyAPIParkRegion = Symbol();\r\nvar s_rideSchedules = Symbol();\r\nvar s_scheduleFilters = Symbol();\r\nvar s_rideTypes = Symbol();\r\n\r\n// API settings\r\nvar api_accessTokenURL = \"https://authorization.go.com/token\";\r\nvar api_accessTokenURLBody = \"grant_type=assertion&assertion_type=public&client_id=WDPRO-MOBILE.MDX.WDW.ANDROID-PROD\";\r\nvar api_accessTokenURLMethod = \"POST\";\r\nvar api_appID = \"WDW-MDX-ANDROID-3.4.1\";\r\nvar api_baseURL = \"https://api.wdpro.disney.go.com/\";\r\n\r\n// use the same user-agent for all WDW park requests\r\nvar api_userAgent = random_useragent.getRandom(function(ua) {\r\n    return (ua.osName == \"Android\");\r\n});\r\n\r\n/**\r\n * Implements the Walt Disney World API framework. All Disney parks use this one API.\r\n * @class\r\n * @extends Park\r\n */\r\nclass WaltDisneyWorldPark extends Park {\r\n    /**\r\n     * Create new WaltDisneyWorldPark Object.\r\n     * This object should not be called directly, but rather extended for each of the individual Disney parks\r\n     * @param {Object} options\r\n     * @param {String} options.resort_id Disney API resort ID\r\n     * @param {String} options.park_id Disney API park ID\r\n     * @param {String} options.park_region Disney API region ID\r\n     * @param {String[]} options.ride_types Array of attraction types to return when getting wait times, eg. [\"Attraction\", \"Entertainment\"]\r\n     */\r\n    constructor(options = {}) {\r\n        options.name = options.name || \"Walt Disney World Resort\";\r\n        options.timezone = options.timezone || \"America/New_York\";\r\n\r\n        // set resort's general center point\r\n        options.latitude = options.latitude || 28.3852;\r\n        options.longitude = options.longitude || -81.5639;\r\n\r\n        // use our userAgent generated randomly on bootup\r\n        options.useragent = api_userAgent;\r\n\r\n        // inherit from base class\r\n        super(options);\r\n\r\n        // grab disney API configuration settings (or throw an error if value is missing/null)\r\n        if (!options.resort_id) throw new Error(\"Missing park's resort ID\");\r\n        this[s_disneyAPIResortID] = options.resort_id;\r\n        if (!options.park_id) throw new Error(\"Missing park's API ID\");\r\n        this[s_disneyAPIParkID] = options.park_id;\r\n        if (!options.park_region) throw new Error(\"Missing park's region\");\r\n        this[s_disneyAPIParkRegion] = options.park_region;\r\n\r\n        // valid ride types to return\r\n        this[s_rideTypes] = options.ride_types || [\"Attraction\"];\r\n        // make sure ride types is an array\r\n        this[s_rideTypes] = [].concat(this[s_rideTypes]);\r\n\r\n        // schedule filters\r\n        this[s_scheduleFilters] = options.schedule_filters || [\"theme-park\"];\r\n        // make sure is array\r\n        this[s_scheduleFilters] = [].concat(this[s_scheduleFilters]);\r\n        // always return attractions\r\n        this[s_scheduleFilters].push(\"Attraction\");\r\n\r\n        // store ride schedules separately and apply them when needed\r\n        this[s_rideSchedules] = {};\r\n    }\r\n\r\n    // override Fastpass Getter to declare support for FastPass\r\n    //  (all Disney parks offer Fastpass)\r\n    get FastPass() {\r\n        return true;\r\n    }\r\n\r\n    // override ride schedule getter to state this park supports ride schedules\r\n    get SupportsRideSchedules() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get our current access token\r\n     */\r\n    GetAccessToken() {\r\n        var expiresIn;\r\n        return this.Cache.Wrap(\"accesstoken\", function() {\r\n            return new Promise(function(resolve, reject) {\r\n                // request a fresh access token\r\n                this.HTTP({\r\n                    url: this.AuthURL,\r\n                    method: api_accessTokenURLMethod,\r\n                    body: this.AuthString,\r\n                    // Disney API doesn't want to return as application/JSON, so we'll manually parse it into a nice object\r\n                    forceJSON: true\r\n                }).then(function(body) {\r\n                    if (!body.access_token) {\r\n                        this.Log(\"Error body\", body);\r\n                        return reject(\"Returned access token data missing access_token\");\r\n                    }\r\n                    if (!body.expires_in) {\r\n                        this.Log(\"Error body\", body);\r\n                        return reject(\"Returned access token data missing expires_in\");\r\n                    }\r\n\r\n                    // parse expires_in into an int\r\n                    var ttlExpiresIn = parseInt(body.expires_in, 10);\r\n\r\n                    // The ttlExpiresIn is the maximum time the access_token is valid. \r\n                    // It's possible for the token to be given back just moments before\r\n                    // it is invalid. Therefore we should force the ttl value in the\r\n                    // cache lower than this value so requests don't fail.\r\n                    expiresIn = Math.ceil(ttlExpiresIn * .90);\r\n\r\n                    this.Log(`Fetched new WDW access_token ${body.access_token}, expires in ${body.expires_in}, caching for a maximum of ${expiresIn}`);\r\n\r\n                    // return our new access token\r\n                    return resolve(body.access_token);\r\n                }.bind(this), reject);\r\n            }.bind(this));\r\n        }.bind(this), function() {\r\n            return expiresIn;\r\n        }.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Fetch a URL from the Disney API\r\n     */\r\n    GetAPIUrl(requestObject) {\r\n        return new Promise(function(resolve, reject) {\r\n            // get access token\r\n            this.GetAccessToken().then(function(access_token) {\r\n                // TODO - build request object\r\n                // make sure headers exist if they weren't set already\r\n                if (!requestObject.headers) requestObject.headers = [];\r\n                requestObject.headers.Authorization = \"BEARER \" + access_token;\r\n                requestObject.headers.Accept = \"application/json;apiversion=1\";\r\n                requestObject.headers[\"X-Conversation-Id\"] = \"WDPRO-MOBILE.MDX.CLIENT-PROD\";\r\n                requestObject.headers[\"X-App-Id\"] = api_appID;\r\n                requestObject.headers[\"X-Correlation-ID\"] = Date.now();\r\n\r\n                // make sure we get JSON back\r\n                requestObject.forceJSON = true;\r\n\r\n                // send network request\r\n                this.HTTP(requestObject).then(resolve, reject);\r\n\r\n            }.bind(this), reject);\r\n        }.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Fetch this Disney Park's waiting times\r\n     * @returns {Promise}\r\n     */\r\n    FetchWaitTimes() {\r\n        return new Promise(function(resolve, reject) {\r\n            // fetch opening times before wait times (so we have opening times to inject into rides)\r\n            this.GetOpeningTimes().then(function() {\r\n                // fetch wait times URL\r\n                this.GetAPIUrl({\r\n                    url: this.FetchWaitTimesURL,\r\n                    // pass in park region also\r\n                    data: {\r\n                        region: this[s_disneyAPIParkRegion]\r\n                    }\r\n                }).then(\r\n                    // success!\r\n                    function(waitTimeData) {\r\n                        // check we have some data\r\n                        if (!waitTimeData || !waitTimeData.entries) {\r\n                            this.Log(\"Error data\", waitTimeData || \"null\");\r\n                            return reject(\"Invalid data returned by WDW API for FetchWaitTimes\");\r\n                        }\r\n\r\n                        // fetch facilities data to inject locations (coming soon) and fastPass availability\r\n                        this.GetFacilitiesData().then((facilitiesData) => {\r\n\r\n                            // apply each ride wait time\r\n                            for (var i = 0, ride; ride = waitTimeData.entries[i++];) {\r\n                                // skip any ride without a name, likely an invalid ride\r\n                                //  eg. the River Rogue Keelboats at DLP are dormant and invalid, but still have a ride object with no name\r\n                                if (!ride.name) {\r\n                                    continue;\r\n                                }\r\n\r\n                                // only keep actual attractions\r\n                                if (this[s_rideTypes].indexOf(ride.type) < 0) {\r\n                                    continue;\r\n                                }\r\n\r\n                                var rideId = CleanRideID(ride.id);\r\n\r\n                                // get the ride object for this ride (will create it if it doesn't exist)\r\n                                var rideObject = this.GetRideObject({\r\n                                    id: rideId,\r\n                                    name: ride.name,\r\n                                });\r\n\r\n                                let rideStatus = (ride.waitTime && ride.waitTime.status) ? ride.waitTime.status.toLowerCase() : \"\";\r\n                                if (rideStatus == \"down\") {\r\n                                    rideObject.WaitTime = -2;\r\n                                } else if (rideStatus == \"operating\") {\r\n                                    rideObject.WaitTime = ride.waitTime.postedWaitMinutes || 0;\r\n                                } else {\r\n                                    rideObject.WaitTime = ride.waitTime.postedWaitMinutes || -1;\r\n                                }\r\n\r\n                                // set fastpass status from facilities data\r\n                                if (facilitiesData[rideId]) {\r\n                                    rideObject.FastPass = facilitiesData[rideId] ? facilitiesData[rideId].fastPass : false;\r\n                                } else {\r\n                                    // no facilities data? fallback on live fastPass availability\r\n                                    rideObject.FastPass = (ride.waitTime &&\r\n                                        // check for both fastpass and fastPass\r\n                                        (ride.waitTime.fastpass && ride.waitTime.fastpass.available) ||\r\n                                        (ride.waitTime.fastPass && ride.waitTime.fastPass.available)\r\n                                    ) ? true : false;\r\n                                }\r\n\r\n                                // some Disney parks return fastpass return times! search them out\r\n                                if (ride.waitTime && ride.waitTime.fastPass) {\r\n                                    if (!ride.waitTime.fastPass.available) {\r\n                                        rideObject.FastPassReturnTimeAvailable = false;\r\n                                    } else {\r\n                                        if (ride.waitTime.fastPass.startTime && ride.waitTime.fastPass.endTime) {\r\n                                            // we have start and end return times! convert to Moment objects and set\r\n                                            rideObject.FastPassReturnTimeStart = Moment.tz(ride.waitTime.fastPass.startTime, \"HH:mm:ss\", this.Timezone);\r\n                                            rideObject.FastPassReturnTimeEnd = Moment.tz(ride.waitTime.fastPass.endTime, \"HH:mm:ss\", this.Timezone);\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                // apply any schedule data we've fetched from opening hour data\r\n                                if (this[s_rideSchedules][rideId]) {\r\n                                    var endFillDate = Moment().tz(this.Timezone).add(90, \"days\");\r\n                                    for (var m = Moment().tz(this.Timezone); m.isBefore(endFillDate); m.add(1, \"day\")) {\r\n                                        var rideScheduleData = this[s_rideSchedules][rideId].GetDate({\r\n                                            date: m\r\n                                        });\r\n                                        if (rideScheduleData) {\r\n                                            rideObject.Schedule.SetDate(rideScheduleData);\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            return resolve();\r\n                        });\r\n                    }.bind(this),\r\n                    // error\r\n                    reject\r\n                );\r\n            }.bind(this), reject);\r\n        }.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Fetch this Disney Park's opening times\r\n     * @returns {Promise}\r\n     */\r\n    FetchOpeningTimes() {\r\n        return new Promise(function(resolve, reject) {\r\n            // get today's date and add on a month to get a decent range of dates\r\n            var rangeStart = Moment.tz(this.Timezone).format(\"YYYY-MM-DD\");\r\n            var rangeEnd = Moment.tz(this.Timezone).add(30, \"days\").format(\"YYYY-MM-DD\");\r\n\r\n            this.GetAPIUrl({\r\n                url: this.FetchScheduleTimesURL,\r\n                data: {\r\n                    \"filters\": this[s_scheduleFilters].join(\",\"),\r\n                    \"startDate\": rangeStart,\r\n                    \"endDate\": rangeEnd,\r\n                    \"region\": this[s_disneyAPIParkRegion]\r\n                }\r\n            }).then(function(scheduleData) {\r\n                if (!scheduleData || !scheduleData.activities) {\r\n                    this.Log(`Missing activities from ${scheduleData}`);\r\n                    return reject(\"Missing activities data from opening times API\");\r\n                }\r\n\r\n                // parse each schedule entry\r\n                for (var i = 0, schedule; schedule = scheduleData.activities[i++];) {\r\n                    // skip if we're missing valid schedule data\r\n                    if (!schedule.schedule) continue;\r\n\r\n                    var scheduleID = CleanRideID(schedule.id);\r\n                    for (var j = 0, scheduleTime; scheduleTime = schedule.schedule.schedules[j++];) {\r\n                        var newScheduleData = {\r\n                            date: Moment.tz(scheduleTime.date, \"YYYY-MM-DD\", schedule.timeZone || this.Timezone),\r\n                            openingTime: Moment.tz(`${scheduleTime.date}T${scheduleTime.startTime}`, \"YYYY-MM-DDTHH:mm:ss\", schedule.timeZone || this.Timezone),\r\n                            closingTime: Moment.tz(`${scheduleTime.date}T${scheduleTime.endTime}`, \"YYYY-MM-DDTHH:mm:ss\", schedule.timeZone || this.Timezone),\r\n                            type: scheduleTime.type,\r\n                            // work out if these are special hours or not\r\n                            specialHours: (scheduleTime.type != \"Operating\" && scheduleTime.type != \"Closed\" && scheduleTime.type != \"Refurbishment\"),\r\n                        };\r\n\r\n                        // check if we've found the actual park's schedule\r\n                        if (scheduleID == this.WDWParkID) {\r\n                            // apply data to our schedule\r\n                            this.Schedule.SetDate(newScheduleData);\r\n                        } else {\r\n                            // else, we must be a ride! (or event/parade or something)\r\n\r\n                            // remember ride schedules and apply them when FetchWaitTimes is called\r\n                            if (!this[s_rideSchedules][scheduleID]) {\r\n                                this[s_rideSchedules][scheduleID] = new Schedule();\r\n                            }\r\n\r\n                            this[s_rideSchedules][scheduleID].SetDate(newScheduleData);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                resolve();\r\n            }.bind(this), reject);\r\n        }.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Get park facilities data\r\n     * Gives us data like whether a ride offers FastPass and their geo-location\r\n     */\r\n    GetFacilitiesData() {\r\n        // cache facilities data for 24 hours (this fetches all data for the resort, so cache at a resort level with a global wrap)\r\n        return this.Cache.WrapGlobal(`${this.WDWResortID}_facilities`, () => {\r\n            // fetch fresh facilities data\r\n            return this.GetAPIUrl({\r\n                url: this.FetchFacilitiesURL,\r\n                method: \"POST\"\r\n            }).then((data) => {\r\n                var facilitiesData = {};\r\n\r\n                for (var i = 0, element; element = data.added[i++];) {\r\n                    if (element.type != \"Attraction\") continue;\r\n\r\n                    // grab ride coordinates (there will be likely multiple)\r\n                    var coordinates = [];\r\n                    for (var locationIDX = 0, location; location = element.relatedLocations[locationIDX++];) {\r\n                        for (var coordinateIDX = 0, coordinate; coordinate = location.coordinates[coordinateIDX++];) {\r\n                            // each ride can have multiple locations\r\n                            //  think: railway, fastPass entrance etc.\r\n\r\n                            var locationName = coordinate.type.trim();\r\n\r\n                            // calculate name for this location\r\n                            if (locationName == \"Guest Entrance\") {\r\n                                // we have a \"Guest Entrance\", rather than calling it that, use the name of this location\r\n                                //  this helps for rides with multiple \"Guest Entrance\"s like the railroad\r\n                                locationName = location.name.trim();\r\n                            }\r\n\r\n                            var geoLoc = new GeoLocation({\r\n                                longitude: coordinate.longitude,\r\n                                latitude: coordinate.latitude\r\n                            });\r\n\r\n                            coordinates.push({\r\n                                location: geoLoc,\r\n                                name: locationName\r\n                            });\r\n                        }\r\n                    }\r\n\r\n                    // add this attraction to our collected data\r\n                    facilitiesData[CleanRideID(element.id)] = {\r\n                        name: element.name.trim(),\r\n                        locations: coordinates,\r\n                        // hilariously some parks call is \"fastPass\" and some \"fastPassPlus\"\r\n                        fastPass: element.fastPass && element.fastPass == \"true\" ? true : (element.fastPassPlus && element.fastPassPlus == \"true\" ? true : false)\r\n                    };\r\n                }\r\n\r\n                return Promise.resolve(facilitiesData);\r\n            }, Promise.reject);\r\n        }, 60 * 60 * 24);\r\n    }\r\n\r\n    /**\r\n     * The URL used to request this park's latest ride waiting times \r\n     * @type {String}\r\n     */\r\n    get FetchWaitTimesURL() {\r\n        // this is a separate function for any parks that need to override this\r\n        return `${this.APIBase}facility-service/theme-parks/${this.WDWParkID};destination\\u003d${this.WDWResortID}/wait-times`;\r\n    }\r\n\r\n    /**\r\n     * The URL used to request this park's schedule data\r\n     * @type {String}\r\n     */\r\n    get FetchScheduleTimesURL() {\r\n        return `${this.APIBase}mobile-service/public/ancestor-activities-schedules/${this.WDWResortID};entityType=destination`;\r\n    }\r\n\r\n    /**\r\n     * The URL used to request the park's facilities data\r\n     * @type {String}\r\n     */\r\n    get FetchFacilitiesURL() {\r\n        return `${this.APIBase}mobile-service/public/destinations/${this.WDWResortID};entityType\\u003ddestination/facilities?region=${this[s_disneyAPIParkRegion]}`;\r\n    }\r\n\r\n    /**\r\n     * Get the API base URL for WDW parks\r\n     * @type {String}\r\n     */\r\n    get APIBase() {\r\n        return api_baseURL;\r\n    }\r\n\r\n    /**\r\n     * Get the Auth URL for WDW parks\r\n     * @type {String}\r\n     */\r\n    get AuthURL() {\r\n        return api_accessTokenURL;\r\n    }\r\n\r\n    /**\r\n     * Get the Auth body used for requesting the auth token\r\n     * @type {String}\r\n     */\r\n    get AuthString() {\r\n        return api_accessTokenURLBody;\r\n    }\r\n\r\n    /**\r\n     * Get the internal WDW Park ID\r\n     * @type {String}\r\n     */\r\n    get WDWParkID() {\r\n        return this[s_disneyAPIParkID];\r\n    }\r\n\r\n    /**\r\n     * Get the internal WDW Resort ID\r\n     * @type {String}\r\n     */\r\n    get WDWResortID() {\r\n        return this[s_disneyAPIResortID];\r\n    }\r\n}\r\n\r\nvar regexTidyID = /^([^;]+)/;\r\n/**\r\n * Clean up a WDW ride id\r\n * IDs are usually in form [id];entityType=Attraction\r\n * This will tidy that up to just return the numeric ID portion at the start\r\n * @private\r\n */\r\nfunction CleanRideID(ride_id) {\r\n    var capture = regexTidyID.exec(ride_id);\r\n    if (capture && capture.length > 1) {\r\n        return capture[1];\r\n    }\r\n    return ride_id;\r\n}\r\n\r\n// export just the Base Disney Park class\r\nmodule.exports = WaltDisneyWorldPark;"]}